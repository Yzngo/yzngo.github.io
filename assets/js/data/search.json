[ { "title": "软件架构", "url": "/posts/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/", "categories": "", "tags": "", "date": "2023-01-05 00:00:00 +0800", "snippet": "软件架构 项目中的每个子系统都有自己的方向，把子系统的决策方向合起来再加入它们之间的关联调用就构成了一个完整的架构，即每个系统、模块、组件都是软件系统架构中的一部分。架构图 在架构设计中，为了能够更好的整理，思考，描述，表达我们的想法；为了让自己和大家能够更加系统的认识架构的意图，结构以及各个子系统。 架构图不关心实现的细节，只关心整体的解决方案。架构图要做到从宏观的角度能看明白整个项目的布局，能够让人一目了然。架构图的分类 UML对象关系图 - 描述数据类之间的关系 部署图 - 描述需要用到的服务器及起到的作用，以及它们之间的相互关系 时序图 - 描述系统程序调用的次序和流程评估架构的好坏以下各方面都很重要，木桶效应里最短的那块木板才是产品好坏的关键。承载力 多个程序员共同工作，彼此工作的模块耦合度是否能够保持原来的设计要求，共同开发时效率是否够高。 当代码行数扩展到100万行时是否依然能够有序且规范地运行。 对于服务器来说，当前架构能够承受多少DU（Daily User）？ 对于客户端来说，当前架构能显示多少UI元素，可渲染多少模型？ 如果承载力太低，访问量一上来就卡在加载页面，大家就不会有耐心来看你的产品了。运营和宣传部门在导入流量时，效果就会大打折扣。这对于单机游戏来说也是成立的，加载时间过长，玩家就不会乐意等待。可扩展性 可扩展性的关键在于，是否能够在添加了新的子系统后不影响或者尽可能少的影响其他子系统的运作。如果添加了新的子系统，其他的系统要全部重构，那就是灾难。易用性 如果强行推动不好用的系统，团队之间就会加深矛盾，会十分影响开发效率。 易用性决定了架构的整体开发效率，程序员容易上手，子系统容易对接，开发效率就高。 易用性的关键是耦合低，只需要关注很少的一部分，就可以完成自己的那份工作可伸缩性 当需要的承载量没有这么大时，可以不使用不需要的功能，化繁为简，只启用需要的部分功能，这样就可以随时简化开发流程。 从客户端的角度，伸缩力体现在是否既能适应大型项目上，如上百人协同开发一个复杂系统，也能适应小项目上，如1～3人小团队的快速开发环境，即小成本小作品的快速迭代。容错性以及错误的感知力 容错性体现在能够防止在使用过程中出现错误而彻底不能使用，需要有备份方案。 从客户端角度看，容错性包括当程序发生错误时，是否同样能够继续保持运行而不崩溃；当这个页面程序出错时，是否依然能够运行其他程序而不闪退或崩溃。 对错误的感知力体现在能够让开发人员及时得知问题已经发生，以及问题的位置，最好能够通过Email等方式自动通知维护者，并记录错误信息。软件架构的思维方式 牢记我们看到的世界都是模块化的组合方式。 必须具备以下三种抽象能力。1. 分层思维 分层是我们应对和管理复杂性的基本思维武器。 把整个系统划分成若干个层次，每一层专注解决某个领域的问题，并向上提供服务。 几个分层案例 Linux操作系统 TCP/IP[[计算机网络|互联网]]协议栈 2. 分治思维 当遇到那些从未处理过的问题，或者特别复杂以至于超出你能力范围的问题时，把它先进行分解、拆分、解剖、撕裂。把大问题分层小问题，再分而治之。小问题解决了，大问题也就解决了。 项目发布流程设计Demo 3. 演化思维 你的架构应该可以不断进化，学习了新的知识就把它加进来。 在软件系统的整个生命周期中，前期的设计占三分，后期的演化占七分。 实际工作中，我们对层级和模块逐个攻破的同时，也进入了架构演化模式。在一开始构建的架构中，某部分的设计可能并不十分合适，在后面的工作中我们需要对其逐步修复、完善甚至替换，这些都是演化的重要步骤。Unity项目框架组成 网络框架 UI框架 数据框架 核心战斗框架 AI框架…. 怎样培养架构设计思维 良好的架构设计思维的培养，离不开工作中大量高质量项目的实战锻炼，以及平时的学习、思考和总结。 架构师在关注技术、开发应用的同时，需要定期梳理自己的架构设计思维，积累的时间长了，看待世界事物的方式会发生根本性的变化，你会发现我们生活的世界，其实也是在抽象、分层、分治和演化的基础上构建起来的。 对抽象、分层、分治和演化掌握的深度和灵活应用的水平，直接决定架构师解决问题域的复杂性和规模大小，是区分普通应用型架构师和平台型/系统型架构师的一个分水岭。 注意架构设计的文档要及时跟进完善，在抽象的过程中，我们需要整理和记录整个过程，以便在今后完善架构 时有途径获得前面在做决策时所考虑的各方面问题。" }, { "title": "Unity Job System", "url": "/posts/Unity-Job-System/", "categories": "", "tags": "", "date": "2022-11-12 00:00:00 +0800", "snippet": "官方文档blit 和 blittable type 是什么？ blit 是位块传送的意思。内存拷贝操作（memory copy operation）有时候被称作位块传送（block transfer），简称为 bit blit。专用于 block transfer 的硬件被称作位块传送器（blitter）。 能够使用 block transfer 的类型在C#中被称作 blittable，即可位块传送的类型。 Blittable 类型是指在托管代码和本机代码中具有相同位级别表示形式的类型。在托管代码和本机代码间[[Marshal 封送]]时无需进行转换。 由于 blittable 类型性能高，应首选这些类型。C#中的 blittable 类型有哪些？ blittable基础类型：byte, sbyte, short, ushort, int, uint, long, ulong, single, double 由blittable基础类型构成的非嵌套一维数组，例如：int[] 仅包含 blittable基础类型 的固定布局的值类型（farmatted value types that contain only blittalbe type）,如 Vector3 Object reference 不是 blittable 类型 托管字符串（managed strings）不是 blittable 类型 char, bool 也不是 blittable 类型NativeContainer NativeContainer 本身是一种托管值类型（struct），为本机内存提供相对安全的C#包装器，它们包含指向非托管分配内存的指针，这些非托管内存在常规的托管内存堆之外，可以被我们的C#代码访问，从而规避了默认的内存管理开销。 与 JobSystem 一起使用时，NativeContainer 允许 JobSystem 访问与主线程共享的数据，而不是使用副本。 定义在Unity.Collections命名空间中的NativeContainer类型 NativeArray - 可以使用 NativeSlice 获取 NativeArray 的子集。 NativeList - 可调整大小的 NativeArray NativeHashMap - 键值对 NativeMultiHashMap - 每个键可以有多个值的键值对 NativeQueue - 队列 使用Demo // 初始化 NativeArray&amp;lt;float&amp;gt; result = new NativeArray&amp;lt;float&amp;gt;(1, Allocator.TempJob); // 释放（处置） result.Dispose(); Jobs Jobs 不能和 objects 一起工作，使用的成员变量只能是 [[blittable]] 或 [[NativeContainer]] 类型。 从主线程访问 Jobs 中的数据只能通过 NativeContainer，blittable 类型的数据，都工作在副本上Job使用流程 Mono类中定义Job struct 托管代码中写入 Job 需要的数据 调度Job做运算，写回数据，用于游戏逻辑Job 接口 Interface 用法 IJob 调度一个与主线程和其他Jobs并行的单独Job，仅执行一次 IJobFor Job接口中最灵活的一个接口 (for代表for循环) IJobParallelFor 对于 NativeArray 中的每一项数据，分别并行执行一次Execute() IJobParallelFprTransform 类似IJobParallelFor，专门用于操作 Transforms JobHandle JobHandle可用于确保 job 完成了。 也可以作为依赖传递给其他的 job，用于确保这些 job 按顺序依次执行。IJob IJob Demo IJob public class ApplyVelocitySample : MonoBehaviour { // 每个 Job 都是实现 IJob 接口的 struct private struct VelocityJob : IJob { // Jobs声明了此Job可以访问的所有数据 // 数据必须是 blittable，或者 NativeContainer // 通过把数据声明为ReadOnly, 多个Jobs允许并行的访问此数据 [ReadOnly] public NativeArray&amp;lt;Vector3&amp;gt; velocity; // 容器默认是 read &amp;amp; write public NativeArray&amp;lt;Vector3&amp;gt; position; // Job需要能够在 worker threads 上独立的执行，需要知道的所有信息 public float deltaTime; public void Execute() { for (var i = 0; i &amp;lt; position.Length; i++) position[i] += velocity[i] * deltaTime; } } public void Update() { // 没有垃圾回收，这样写没问题，每帧 new 值类型是没问题的 // NativeContainer只是个壳子，里面有个指针 var position = new NativeArray&amp;lt;Vector3&amp;gt;(500, Allocator.Persistent); var velocity = new NativeArray&amp;lt;Vector3&amp;gt;(500, Allocator.Persistent); for (var i = 0; i &amp;lt; velocity.Length; i++) { velocity[i] = new Vector3(0, 10, 0); } // 初始化Job的数据 var job = new VelocityJob { deltaTime = Time.deltaTime, position = position, velocity = velocity }; // 调度方法以扩展方法的形式实现 // 1.在单一工作线程上调度 job, 返回的 JobHandle 可以使进行后续操作 JobHandle jobHandle = job.Schedule(); // 2.直接在主线程上调度 job，无并行性 job.Run(); // 确保 job 已完成 // 不建议这样做，因为这样实际上丧失了并行性。 jobHandle.Complete(); // 读取 job 运算之后的结果 Debug.Log(job.position[0].ToString()); // Native arrays 必须手动释放 position.Dispose(); velocity.Dispose(); } } IJobFor IJobFor Demo IJobForpublic class ApplyVelocityParallelForSample : MonoBehaviour{ private struct VelocityJob : IJobFor { [ReadOnly] public NativeArray&amp;lt;Vector3&amp;gt; velocity; public NativeArray&amp;lt;Vector3&amp;gt; position; public float deltaTime; public void Execute(int i) { position[i] += velocity[i] * deltaTime; } } public void Update() { var position = new NativeArray&amp;lt;Vector3&amp;gt;(500, Allocator.Persistent); var velocity = new NativeArray&amp;lt;Vector3&amp;gt;(500, Allocator.Persistent); for (var i = 0; i &amp;lt; velocity.Length; i++) { velocity[i] = new Vector3(0, 10, 0); } var job = new VelocityJob() { deltaTime = Time.deltaTime, position = position, velocity = velocity }; // 直接在主线程上调度 job，第一个参数为执行的迭代次数 job.Run(position.Length); // 之后的某个时间点，在单一工作线程上调度此job JobHandle scheduleJobDependency = new JobHandle(); JobHandle scheduleJobHandle = job.Schedule(position.Length, scheduleJobDependency); // 在并行的 N 个工作线程上调度此job // 第二个参数为 batch size, 即每个batch的任务数量；这个参数怎样设置？ JobHandle scheduleParallelJobHandle = job.ScheduleParallel(position.Length, 64, scheduleJobHandle); // It is not recommended to Complete a job immediately, // since that reduces the chance of having other jobs run in parallel with this one. // You optimally want to schedule a job early in a frame and then wait for it later in the frame. scheduleParallelJobHandle.Complete(); Debug.Log(job.position[0].ToString()); position.Dispose(); velocity.Dispose(); }}IJobParallelFor IJobParallelFor Demo IJobParallelFor Demo public class ApplyVelocityParallelForSample : MonoBehaviour{ private struct VelocityJob : IJobParallelFor { [ReadOnly] public NativeArray&amp;lt;Vector3&amp;gt; velocity; public NativeArray&amp;lt;Vector3&amp;gt; position; public float deltaTime; public void Execute(int i) { position[i] += velocity[i] * deltaTime; } } public void Update() { var position = new NativeArray&amp;lt;Vector3&amp;gt;(500, Allocator.Persistent); var velocity = new NativeArray&amp;lt;Vector3&amp;gt;(500, Allocator.Persistent); for (var i = 0; i &amp;lt; velocity.Length; i++) { velocity[i] = new Vector3(0, 10, 0); } var job = new VelocityJob { deltaTime = Time.deltaTime, position = position, velocity = velocity }; JobHandle jobHandle = job.Schedule(position.Length, 64); jobHandle.Complete(); Debug.Log(job.position[0].ToString()); position.Dispose(); velocity.Dispose(); }}Parallel Job Batch Size 对于简单的任务，比如把几个Vector3向量相加，，batch size 可以是 32 到 128 对于昂贵的任务，batch size 最好小一些，甚至设为 1 都是可以接受的Tips Don’t try to update NativeContainer contents. nativeArray[0]++; is the same as writing var temp = nativeArray[0]; temp++ MyStruct temp = myNativeArray[i]; temp.memberVariable = 0; myNativeArray[i] = temp; " }, { "title": "Unitask", "url": "/posts/UniTask/", "categories": "", "tags": "", "date": "2022-10-25 00:00:00 +0800", "snippet": "UniTask/README_CN.mdUniTask v2 — Zero Allocation async/await for Unity, with Asynchronous LINQUniTask 为Unity提供一个高性能，0 GC 的 async/await 异步方案。 基于值类型的 UniTask&amp;lt;T&amp;gt; 和自定义的 AsyncMethodBuilder 来实现0GC。 使所有 Unity 的 AsyncOperations 和 Coroutines 可等待。 基于 PlayerLoop 的任务( UniTask.Yield, UniTask.Delay, UniTask.DelayFrame, etc..) 可以替换所有协程操作。 对 MonoBehaviour 消息事件和 uGUI 事件进行 可等待/异步枚举 拓展。 完全在 Unity 的 PlayerLoop 上运行，因此可以不使用 Thread。 提供一个 TaskTracker EditorWindow 以追踪所有UniTask分配来预防内存泄漏。 与原生 Task/ValueTask/IValueTaskSource 高度兼容的行为。 安装 通过 [[OpenUPM]] 安装。openupm-cn add com.cysharp.unitask命名空间using Cysharp.Threading.Tasks;返回类型// 替代 async void, 是 UniTask的轻量级版本async UniTaskVoid// 如果要调用返回 UniTaskVoid 的方法，需要 ForgetTestAsync().Forget();// UniTask 可以用到 Mono 的 Start 方法中private async UniTaskVoid Start(){}// 替代Task&amp;lt;T&amp;gt;的轻量级方案async UniTask&amp;lt;T&amp;gt;await 不能多次等待同一个 await 实例，每个 await 实例最多只能等待一次。// 等待到下一帧 await UniTask.Yield(); // 最轻量，最快await UniTask.NextFrame(); // = = yield return null// 等待任何 playerloop 的生命周期await UniTask.Yield(PlayerLoopTiming.PreLateUpdate);// 等待此帧结束 = yield return new WaitForEndOfFrameawait UniTask.WaitForEndOfFrame(this);// 等待100帧（就像一个协程一样）await UniTask.DelayFrame(100);// 等待特定时长，并且可以设置在 PlayerLoop 返回的时刻 = new WaitForSeconds()await UniTask.Delay(TimeSpan.FromSeconds(1), true, PlayerLoopTiming.Update);// yield return WaitUntil 替代方案await UniTask.WaitUntil(() =&amp;gt; isActive == false);// WaitUntil拓展，指定某个值改变时触发await UniTask.WaitUntilValueChanged(this, x =&amp;gt; x.isActive);// await一个协程await FooCoroutineEnumerator();// 你可以直接 await 一个原生 taskawait Task.Run(() =&amp;gt; 100);取消和超时取消之后， await 后的逻辑不再执行。 new 一个 CancellationTokenSource// 使用 CancellationTokenSourcevar cts = new CancellationTokenSource();// 可选，设置自动超时cts.CancelAfterSlim(TimeSpan.FromSeconds(5f));cancelButton.onClick.AddListener(() =&amp;gt;{ cts.Cancel();});await UniTask.DelayFrame(1000, cancellationToken: cts.Token).SuppressCancellationThrow(); 调用 MonoBehaviour 的 GetCancellationTokenOnDestroy// 获取一个依赖对象生命周期的Cancel句柄// 当对象被销毁时，将会调用这个Cancel句柄，从而实现取消的功能CancellationToken cancellationToken = this.GetCancellationTokenOnDestroy();// 为异步操作启用取消功能var (isCanceled, result) = await Resources.LoadAsync&amp;lt;TextAsset&amp;gt;(&quot;bar&quot;) .WithCancellation(cancellationToken).SuppressCancellationThrow(); 取消链式异步方法，所有异步方法都建议最后一个参数接受 cancellationToken，并将 CancellationToken 从头传递到尾。await FooAsync(this.GetCancellationTokenOnDestroy());// ---async UniTask FooAsync(CancellationToken cancellationToken){ await BarAsync(cancellationToken).SuppressCancellationThrow();}async UniTask BarAsync(CancellationToken cancellationToken){ await UniTask.Delay(TimeSpan.FromSeconds(3), cancellationToken).SuppressCancellationThrow();} 任意生命周期内取消异步操作。public class MyBehaviour : MonoBehaviour{ CancellationTokenSource disableCancellation = new CancellationTokenSource(); CancellationTokenSource destroyCancellation = new CancellationTokenSource(); private void OnEnable() { if (disableCancellation != null) { disableCancellation.Dispose(); } disableCancellation = new CancellationTokenSource(); } private void OnDisable() { disableCancellation.Cancel(); } private void OnDestroy() { destroyCancellation.Cancel(); destroyCancellation.Dispose(); }} 链接多个取消Tokenvar cancelToken = new CancellationTokenSource();cancelButton.onClick.AddListener(()=&amp;gt;{ cancelToken.Cancel(); // 点击按钮后取消});var timeoutToken = new CancellationTokenSource();timeoutToken.CancelAfterSlim(TimeSpan.FromSeconds(5)); // 设置5s超时try{ // 链接token var linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancelToken.Token, timeoutToken.Token); await UnityWebRequest.Get(&quot;http://foo&quot;).SendWebRequest().WithCancellation(linkedTokenSource.Token);}catch (OperationCanceledException ex){ if (timeoutToken.IsCancellationRequested) { UnityEngine.Debug.Log(&quot;Timeout.&quot;); } else if (cancelToken.IsCancellationRequested) { UnityEngine.Debug.Log(&quot;Cancel clicked.&quot;); }}进度// Progress.Createvar asset = await Resources.LoadAsync&amp;lt;TextAsset&amp;gt;(&quot;baz&quot;) .ToUniTask(Progress.Create&amp;lt;float&amp;gt;(x =&amp;gt; Debug.Log(x)));// 实现 IProgress&amp;lt;T&amp;gt; 接口public class Foo : MonoBehaviour, IProgress&amp;lt;float&amp;gt;{ public void Report(float value) { UnityEngine.Debug.Log(value); } public async UniTaskVoid WebRequest() { var request = await UnityWebRequest.Get(&quot;http://google.co.jp&quot;) .SendWebRequest() .ToUniTask(progress: this); }}PlayerLoop Delay，DelayFrame，ToUniTask 等可以接受 PlayerLoopTiming 枚举值参数，指定异步何时运行。 PlayerLoopList.md · GitHubMonoBehaviour 事件 所有 MonoBehaviour 消息事件都可以转换异步流AsyncTriggers， 可以通过 using Cysharp.Threading.Tasks.Triggers; 启用 通过 this.GetAsync***Trigger 触发，再通过 GetAsync***Handler 获取句柄// every updatethis.GetAsyncUpdateTrigger().ForEachAsync(_ =&amp;gt;{ Debug.Log(&quot;VAR&quot;);});// 碰撞两次后执行var trigger = this.GetAsyncCollisionEnterTrigger().GetOnCollisionEnterAsyncHandler();await trigger.OnCollisionEnterAsync();await trigger.OnCollisionEnterAsync();Debug.Log(&quot;VAR&quot;);实用函数UniTask.WhenAll() 等待所有异步结束UniTask.WhenAny() 等待任何一个异步结束// ---------------------------public async UniTaskVoid LoadManyAsync(){ // 并行加载. var (a, b, c) = await UniTask.WhenAll( LoadAsSprite(&quot;foo&quot;), LoadAsSprite(&quot;bar&quot;), LoadAsSprite(&quot;baz&quot;));}async UniTask&amp;lt;Sprite&amp;gt; LoadAsSprite(string path){ var resource = await Resources.LoadAsync&amp;lt;Sprite&amp;gt;(path); return (resource as Sprite);}异步流 asynchronous stream support 所有标准 LINQ 查询运算符都可以应用于异步流. 除了标准查询运算符之外，还有其他 Unity 生成器，例如EveryUpdate、Timer、TimerFrame、Interval、IntervalFrame和EveryValueChanged。并且还添加了额外的 UniTask 原始查询运算符，如Append, Prepend, DistinctUntilChanged, ToHashSet, Buffer, CombineLatest, Do, Never, ForEachAsync, Pairwise, Publish, Queue, Return, SkipUntil, TakeUntil, SkipUntilCanceled, TakeUntilCanceled, TakeLast, Subscribe// 下面的语法可以代替 Updateawait foreach (var _ in UniTaskAsyncEnumerable.EveryUpdate(token)){ Debug.Log(&quot;Update() &quot; + Time.frameCount);}// 将 Where 过滤器应用于每两次单击运行一次的按钮单击异步流await okButton.OnClickAsAsyncEnumerable().Where((x, i) =&amp;gt; i % 2 == 0).ForEachAsync(_ =&amp;gt;{});// fire and forget，每两次响应一次，和 ForEachAsync 结果相同okButton.OnClickAsAsyncEnumerable().Where((x, i) =&amp;gt; i % 2 == 0).Subscribe(_ =&amp;gt;{});UniTaskTracker 通过 Window -&amp;gt; UniTask Tracker 打开跟踪器窗口。 UniTaskTracker 仅用于调试用途，因为启用跟踪和捕获堆栈跟踪很有用，但会对性能产生重大影响。推荐的用法是启用跟踪和堆栈跟踪以查找任务泄漏并在完成时禁用它们。使用线程// 之后切换到线程池模式await UniTask.SwitchToThreadPool();// 转回主线程await UniTask.SwitchToMainThread();DoTween支持[[DOTween]] 需要添加 UNITASK_DOTWEEN_SUPPORT 符号定义？[[CS-操作符和控制流程#预处理器指令]] DOTween 支持的默认行为 (await, WithCancellation, ToUniTask) await 等待动画播放完毕。private void Start(){ MoveAsync().Forget();}private async UniTaskVoid MoveAsync(){ await transform.DOMoveX(2, 10); await transform.DOMoveZ(5, 20); var ct = this.GetCancellationTokenOnDestroy(); await UniTask.WhenAll( transform.DOMoveX(10, 3).WithCancellation(ct), transform.DOScale(10, 3).WithCancellation(ct)); )}Addressables支持[[Addressable]] 等待 AsyncOperationHandle，AsyncOperationHandle&amp;lt;T&amp;gt;//要读取的 AssetReference[SerializeField] AssetReference _target;[SerializeField] private RawImage _image;private void Start(){ var token = this.GetCancellationTokenOnDestroy(); InitializeAsync(_target, token).Forget();}private async UniTaskVoid InitializeAsync(AssetReference target, CancellationToken token){ //等待 Addressables.load 与 await 异步加载资产 var texture = await Addressables.LoadAssetAsync&amp;lt;Texture&amp;gt;(target) .WithCancellation(token); _image.texture = texture;}Resources支持[[Resources文件夹]]// 直接等待Unity的AsynchronousObjectvar asset = await Resources.LoadAsync&amp;lt;TextAsset&amp;gt;(&quot;foo&quot;);SceneManager支持[[Unity-SceneManager]] 不要使用 LoadSceneAsync.ToUniTaskawait SceneManager.LoadSceneAsync(&quot;scene2&quot;);uGUI事件支持 所有 uGUI 组件都实现了 AsAsyncEnumerable 异步事件流的转换。 使用异步可迭代和 LINQ Where 查询操作符实现每两次点击按钮执行操作private void Awake(){ // fire and forget okButton.OnClickAsAsyncEnumerable().Where((x, i) =&amp;gt; i % 2 == 0).Subscribe(_ =&amp;gt; { Debug.Log(&quot;Click every two times&quot;); });} Demo - 检测3次点击事件private void Start(){ TripleClick().Forget();}async UniTask TripleClick(){ while(true) { // 默认情况下，使用了button.GetCancellationTokenOnDestroy 来管理异步生命周期 await button.OnClickAsync(); await button.OnClickAsync(); await button.OnClickAsync(); Debug.Log(&quot;Three times clicked&quot;); }}// 更高效的方法async UniTask TripleClick(){ using var handler = okButton.GetAsyncClickEventHandler(); await handler.OnClickAsync(); await handler.OnClickAsync(); await handler.OnClickAsync(); Debug.Log(&quot;Three times clicked&quot;);}// 使用异步LINQasync UniTask TripleClick(CancellationToken token){ await okButton.OnClickAsAsyncEnumerable().Take(3).LastAsync(); Debug.Log(&quot;Three times clicked&quot;);}// 使用异步LINQasync UniTask TripleClick(CancellationToken token){ await button.OnClickAsAsyncEnumerable().Take(3).ForEachAsync(_ =&amp;gt; { // 每一次点击都执行 Debug.Log(&quot;Every clicked&quot;); }); // 3次之后才执行 Debug.Log(&quot;Three times clicked, complete.&quot;);}UnityWebRequest支持[[UnityWebRequest]]// 1var txt = (await UnityWebRequest.Get(&quot;https://...&quot;).SendWebRequest()).downloadHandler.text;// 2UnityWebRequest req = new UnityWebRequest(); var op = await req.SendWebRequest();return op.downloadHandler.text;// 3var task1 = GetTextAsync(UnityWebRequest.Get(&quot;http://google.com&quot;));" }, { "title": "行为树", "url": "/posts/%E8%A1%8C%E4%B8%BA%E6%A0%91/", "categories": "", "tags": "", "date": "2022-10-10 00:00:00 +0800", "snippet": "参考资料 Behavior trees for AI: How they work好用的行为树插件 Behavior Designer NodeCanvas Fluid Behavior Tree - GitHub - 代码驱动行为树行为树的基本概念 行为树采用策略型思考方式编写。 行为树的本质是树状节点，是一种树形的父子节点之间的逻辑结构，通过扩展节点的功能来实现复杂的行为逻辑。 行为树可以使用节点搭建一个庞大的AI模型。这些节点就像一个个的积木块，用这些节点搭建完整AI的过程就像是搭积木。行为树中的节点表现节点 Behavior Node整颗行为树中，只有条件节点和行为节点能成为叶子节点，只有这两种是项目中要特别定制的节点。条件节点 Condition Node 条件满足返回true，不满足返回false 常用的条件节点有：大于，小于，等于，与或非等等 应用场景有：判断血量，判断距离，判断状态，判断时间间隔等等行为节点 Action Node Action 一般都是最后的叶子节点，对应了游戏中的某个具体行为，在完成具体的一次行为后根据计算或者配置返回值。 行为节点都是根据项目的需要从基础行为节点扩展而来，行为节点是最更富的节点库，大部分时间程序员都是在修改和扩容行为节点， 应用场景有：行走到目标点，追击目标，使用物品，撤退，攻击目标，防御，释放技能等等。决策节点 Decider Node复合节点和修饰节点用于控制行为树中的决策走向，一般不需要根据项目定制。复合节点 Composite Node 复合节点可以有一个或者多个子节点。复合节点决定了子节点的执行顺序。 选择节点和顺序节点可以进一步提供非线性迭代的加权随机变种。 并发节点提供了并发性，可以利用线程或协程提供并发操作，性能高。一般在并发节点下面并行挂载多个Action子树或多个条件节点，以提供实时性。选择节点 Selector 按顺序迭代执行子节点，遇到第一个返回true的子节点，停止迭代，返回true。 如果所有子节点都返回false，则返回false。 变种：随机权重选择节点（Weight Random Selector），每次执行不同的起点为每次执行不同的 first true 子节点提供了可能性。顺序节点 Sequence 按顺序迭代执行子节点，遇到一个返回false的子节点，停止迭代，返回false。 如果所有子节点都返回true，则返回true。 变种：随机权重顺序节点（Weight Random Sequence），可以提供不同的随机迭代顺序，避免AI总是出现可预期的结果，让结果更具随机性。并行选择节点 Parallel Selector 并行执行所有子节点，执行完所有子节点后，如果有一个子节点返回true，则返回true。 如果所有子节点都返回false，则返回false。并行顺序节点 Parallel Sequence 并行执行所有子节点，执行完所有子节点后，如果有一个子节点返回false，则返回false。 如果所有子节点都返回true，则返回true。并行混合节点 Parallel Hybird 并行执行所有子节点，执行完所有子节点后，按指定数量的节点返回true或false后再决定返回结果。修饰节点 Decorator Node 修饰节点只能有一个子节点。在其子节点执行后，对返回的结果进行修饰后返回给它的父节点。 修饰节点都可以自定义出来，其功能五花八门反向修饰 Not 将子节点的结果取反后返回给父节点。直到失败修饰 Failure Until 在子节点到达指定的次数前一直向父级返回false，子节点到达指定的次数后，返回true总是失败修饰 Fail 总是返回false计数修饰 Counter 只运行子节点n次，超过n次后不再运行。时间修饰 Time 在指定的时间内运行子节点后都返回true，超过时间范围总返回false。不做任何事 Nothing 什么都不干，占个位置。日志 Log 打印日志，告知开发者当前节点的位置和相关信息。优点 单个节点易扩展。 通过一些简单的操作就能制作出能够达到人类预期的足够复杂的 AI 行为。" }, { "title": "Unity Ugui 事件系统分析", "url": "/posts/Unity-uGUI-%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/", "categories": "", "tags": "", "date": "2022-08-08 00:00:00 +0800", "snippet": "Event System Event System 组件本身仅仅作为整个事件系统的管理器，或者不同事件系统组件的辅助器。 如果不需要处理玩家的输入事件，可以把 Event System 删掉。 Event System 并非uGUI专用的，也可以用于其他用途。 工作流程：Unity输入系统检测到用户输入，Input Modules 处理用户输入，从摄像机的屏幕位置上通过 Raycasters 检测用户点击到的对象（通过坐标计算或射线检测），把输入数据存储到 Event Data 中，再通过 Messaging System 通知对象响应事件。Input Modules - 输入模块 Input Modules 承担了整个事件系统的业务逻辑，是事件系统的核心模块。 默认的 StandaloneInputModule 对接的是 Unity.Input 主要功能为： 处理输入系统提供的输入事件 管理事件状态 发送事件到场景对象 同一时刻只能有一个 Input Module 被激活，且必须和 Event System 组件放在同一个物体上。Raycasters - 射线投射模块Graphic Raycaster 供 UI 对象使用。必须挂载在 [[Canvas]] 上，管理他下面的所有子UI物体的点击响应方式。 通过坐标计算检测点击到的对象。 Graphic Raycaster 只对该Canvas下的点击交互起作用，而 Physics 类里面的API不影响UI上面的交互。 遇到一些交互部件没响应时，可以检查这里是否出问题了。 可以设置完全忽略输入的方式来彻底取消点击响应，还可以指定阻止对某些layers进行响应。Physics (2D) Raycaster 供 3D (2D) physics 物体使用。必须挂载在 [[Camera]] 上。 通过[[射线碰撞检测]]进行 3D (2D) 物体的点击判断。 2D 以层级次序排序，3D 以距离摄像机的远近排序。3D物体响应事件需要满足的条件 Physics (2D) Raycaster 挂载到相机上。 响应物体挂载[[碰撞体]]组件。 编写实现 uGUI 的[[事件接口]]的脚本挂载到物体上。 物体不被UI遮挡。Message System - 消息分发模块 没有一个组件叫 Message System，它是指整个消息系统。 Message System消息系统用来代替 Unity 内置的 SendMessage。设法解决(address)了一些 SendMessage 存在的问题。 消息系统一般用于松耦合的关系。比如：脚本响应触摸事件等。 消息系统可以独立于uGUI使用。自定义消息using UnityEngine.EventSystems;// 自定义消息接口public interface ICustomMessageTarget : IEventSystemHandler{ // messaging system 可以调用的函数 void Message1(); void Message2();}// 查找实现了某消息接口的物体接收消息 // MonoBehaviour 实现接口以接收消息public class CustomMessageTarget : MonoBehaviour, ICustomMessageTarget{ public void Message1() { Debug.Log (&quot;Message 1 received&quot;); } public void Message2() { Debug.Log (&quot;Message 2 received&quot;); }}触发消息 通过messaging system 发送消息要指明消息类型+目标 GameObject，目标GameObject上所有实现了该消息接口的组件都能够收到消息。 发送消息时可以指定一些自定义数据。也可以指定触发范围，仅在自己身上触发，还是包括parent 或者 children ？using UnityEngine.EventSystems;ExecuteEvents.Execute&amp;lt;ICustomMessageTarget&amp;gt;(targetObject, pointerEventData, (x,y)=&amp;gt;x.Message1());ExecuteEvents.ExecuteHierarchy();Event Data - 事件参数BaseEventData 是所有事件数据的基类PointerEventData 点位事件数据类，为数据类的核心类，存储了大部分事件系统逻辑需要的数据，包括按下位置，松开与按下时间差，拖拽位移差，点击的物体等等，承载了所有输入事件需要的数据。AxisEventData 轴类输入数据类，如手柄摇杆数据等。Event Trigger 组件 事件触发器也需要 Image 组件用于接收事件。 使用Image接收事件，使用EventTrigger触发业务函数。使用 Event Trigger 动态绑定事件private void Start(){ // 先给按钮添加EventTrigger EventTrigger et1 = button.AddComponent&amp;lt;EventTrigger&amp;gt;(); et1.triggers = new List&amp;lt;EventTrigger.Entry&amp;gt;(); EventTrigger.Entry entry1 = new EventTrigger.Entry(); // 指定事件类型，PointerDown 指鼠标按下事件 entry1.eventID = EventTriggerType.PointerDown; entry1.callback.AddListener(OnBtnEvent); // 响应函数为OnBtnEvent // 将Entry添加到事件列表中，可以添加多个 et1.triggers.Add(entry1);}Event Trigger 示例 使用EventTrigger对图片进行点击，拖拽，移入移出 var self = _image.gameObject.AddComponent&amp;lt;EventTrigger&amp;gt;(); self.triggers = new List&amp;lt;EventTrigger.Entry&amp;gt;(3) { new EventTrigger.Entry() { eventID = EventTriggerType.BeginDrag, callback = new EventTrigger.TriggerEvent() }, new EventTrigger.Entry() { eventID = EventTriggerType.Drag, callback = new EventTrigger.TriggerEvent() }, new EventTrigger.Entry() { eventID = EventTriggerType.EndDrag, callback = new EventTrigger.TriggerEvent() } }; //开始拖拽 self.triggers[0].callback.AddListener((d) =&amp;gt; { objDrag = Instantiate(self.gameObject, self.transform.parent); objDrag.GetComponent&amp;lt;Image&amp;gt;().raycastTarget = false; }); //拖拽中 self.triggers[1].callback.AddListener((d) =&amp;gt; { if (objDrag != null) { Vector3 pos; if (RectTransformUtility.ScreenPointToWorldPointInRectangle(panel, Input.mousePosition, UICamera,out pos)) { objDrag.transform.position = pos; } } }); //拖拽结束 self.triggers[2].callback.AddListener((d) =&amp;gt; { });" }, { "title": "渲染优化 静态合批", "url": "/posts/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96-%E9%9D%99%E6%80%81%E5%90%88%E6%89%B9/", "categories": "", "tags": "", "date": "2022-07-25 00:00:00 +0800", "snippet": "静态合批 静态合批在离线状态下生成合并的网格，并以文件的形式存储合并之后的数据。当场景被加载时，这些合并的网格数据一并被加载到内存中，渲染时提交给GPU。静态合批会在项目中生成一个较大的VBO（Vertex Buffer Object）和IBO（Index Buffer Object），Runtime时会通过该VBO进行渲染。 本质上是用内存+带宽换取CPU和GPU的效率提升。 更适合我们能容忍内存扩大的情况。合并需要满足的条件 需要静态合批的模型要做好 static 标记，且运行时不能移动，旋转或缩放，不能有动画。 无论模型多大，只要模型的材质球相同，就会被静态批处理优化。 静态合批的模型需要打开 [[read/write]] 选项。 被合批的模型要有相同的顶点属性。 每次静态自动合批最多包含64000个顶点和64000个索引。优点 离线合批，不会在运行时增加CPU的消耗。 减少了DrawCall。缺点 即使一些物体之前共用同一个模型，Unity也会复制出每一份模型实例用以合并。所以需要更多的内存存储合并之后的模型。有时我们需要减少对物体的静态处理以减少内存的使用量。 离线生成的网格会被整体提交，当网格过大时，会导致CPU和GPU的带宽消耗过大。 只有完全不动的静态物体才能使用静态批处理。 增大了发布游戏包的体积。Unity代码静态合批 StaticBatchingUtility.Combine(); - StaticBatchingUtility" }, { "title": "渲染优化 手动合批", "url": "/posts/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96-%E6%89%8B%E5%8A%A8%E5%90%88%E6%89%B9/", "categories": "", "tags": "", "date": "2022-07-25 00:00:00 +0800", "snippet": "手动合批方法 生成新的合批后的模型后要隐藏原有的模型，以免两个模型重叠显示。// CombineInstances 承载了所有需要合并的数据,包括网格，子网格，世界坐标矩阵等...CombineInstance[] combineInstances = new CombineInstance[meshFiltersToCombine.Count];for(int i = 0 ; i&amp;lt; meshFiltersToCombine.Count ; i++){ // combineInstance 是个 struct，可以直接赋值，不需要new combineInstances[i].mesh = meshFiltersToCombine[i].sharedMesh; combineInstances[i].transform = meshFiltersToCombine[i].transform.localToWorldMatrix; combineInstances[i].subMeshIndex = i; // 标识Material的索引位置，可以为0、1、2等}meshFilterCombined.sharedMesh.CombineMeshes(combineInstances, true, true);手动合批需要满足的条件 需要合并的模型需要选中 [[read/write]]。 合批的模型距离不要太远，不能太大，以防CPU裁剪失效。 要求模型使用相同的材质球。 手动合并网格之后，Unity不能单独 Cull 其中的子网格；如果合并之后的网格有一部分在屏幕上，则Unity会绘制整个合并的Mesh。手动拼接网格的缺点 拼接网格时可能会有卡顿的情况。" }, { "title": "渲染优化 动态批处理", "url": "/posts/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96-%E5%8A%A8%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86/", "categories": "", "tags": "", "date": "2022-07-25 00:00:00 +0800", "snippet": "Dynamic Batch的尴尬之处：减少DrawCall是为了减少CPU消耗，而合批计算又需要消耗CPU，关键这玩意还要每帧都重新计算，不如手动合批！动态合批 在CPU中把小网格合并成一个大网格，打组一起送到GPU，并在一个draw Call中渲染它们。 开启动态合批时，Unity每帧通过遍历所有的渲染模型，检测视锥体内的非动画模型，筛选符合条件的模型进行合批操作，将他们的网格合并后与材质球一起传给GPU绘制。 更适合同一个材质球并且模型面数较少的情况。合并需要满足的条件 材质球实例相同才会被合并。 不能用于超过900个顶点属性的网格。即如果只有顶点坐标，则支持900个顶点；如果有顶点坐标，法线和UV，则支持300个顶点；如果使用顶点坐标、法线、UV0、UV1和切线，则支持180个顶点。 被合并的网格缩放比例要相同；例如物体A的缩放比例是（1:1:1），物体B的缩放比例是（1:1:2），它们的缩放比例不同，则不会被合并处理。 如果使用光照贴图的数据，必须是相同的才有机会合批。 具有多个Pass的着色器增加了渲染管道，绝对不会被动态批处理。 延迟渲染无法被合批。缺点 条件苛刻，很难有模型符合动态批处理的要求。 需要消耗 CPU 把所有的顶点转换到世界空间，合并网格也会带来开销。如果降低DrawCall带来的好处被合并网格消耗的大量CPU运算抵消掉了，就很得不偿失。" }, { "title": "渲染优化 Srp Batcher", "url": "/posts/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96-SRP-Batcher/", "categories": "", "tags": "", "date": "2022-07-25 00:00:00 +0800", "snippet": "SRP Batcher 原理 SRP Batcher并没有减少 [[DrawCall]] 的数量，只是效率更高，优化了每一次Drawcall的耗时。合批条件 只需要Shader变体相同，不需要材质相同。 渲染的物体必须是一个 [[Mesh]] 或者 [[SkinnedMesh]]。不能是粒子。 [[Shader]] 代码必须兼容 SRP Batcher。 不能用代码修改 [[MaterialPropertyBlock]], 会破坏SRP Batcher。Shader兼容 SRP Batcher 必须声明所有内建引擎properties 在一个名为”UnityPerDraw”的CBUFFER里。注意事项 如果项目启用了SRP Batcher，[[GPU instancing]] 就不再生效，可以使用代码做GPU实例化。" }, { "title": "渲染优化 Gpu Instancing", "url": "/posts/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96-GPU-Instancing/", "categories": "", "tags": "", "date": "2022-07-25 00:00:00 +0800", "snippet": "Graphics.DrawMeshInstancedGPU Instancing是什么？ GPUInstancing是一种GPU优化手段，可以让CPU用一个 DrawCall 命令控制GPU绘制某个网格的大量实例，这些网格使用相同的material。 GPU Instancing 是显卡的一个特性，大部分图形API都能提供的一种技术，其表象为当我们绘制1000个物体时，它只将模型数据及1000个坐标提交给显卡，这1000个物体不同的位置、状态、颜色等将整合成一个Per Instance Attribute的Buffer提交给GPU，这使得GPU可以在着色器中区别对待传入的网格数据。这样做的好处是只需要提交一次就能绘制所有不同位置的物体，这大大减少了提交次数，对于绘制大量相同模型的情况这种技术可以提高效率，同时也能避免因合批而造成内存浪费。 使用GPU instancing绘制的对象在Frame Debugger中显示为 Draw Mesh(instanced)需要满足的条件 需要Shader着色器支持GPU Instancing（需要根据Instancing索引提取的参数来改变顶点或颜色等数据）。 所有待渲染的对象需要使用相同的着色器，材质球和网格，不能有骨骼动画。 使用 GPU Instancing就不能再使用 [[SkinnedMeshRenderer]] 或 [[Animator]] 计算蒙皮网格了。 和SRP Batcher不兼容，且SRP Batcher优先级更高。如果使用SRP，要使GPU Instancing生效，需要SRP的设置中取消SRP Batcher。或者通过代码使用GPU Instancing。 SkinnedMeshRenderers不支持GPU instancing。 不支持WebGL 1.0。适用场景 GPU Instancing更适合同一个模型渲染多次的情况Shader开启Instancing功能 URPAssets -&amp;gt; Show Additional -&amp;gt; 关闭SRP Batcher Material 中勾上 Enable GPU Instancing 如果只在一个坐标上渲染多次模型是没有意义的，我们需要将一个模型渲染到不同的多个地方，并且需要有不同的缩放大小和旋转角度，以及不同的材质球参数。 GPU Instancing功能为我们提供了一个叫 InstancingID 的变量，这个变量可以确定当前着色计算的是第几个实例。Vertex Shader 和 Fragment Shader 可以通过这个变量获取模型矩阵，颜色等不同的参数，（烘焙动画可以通过InstancingID改变当前实例动画帧的偏移量）。简单的DemoShader &quot;SimplestInstancedShader&quot;{ Properties { _Color (&quot;Color&quot;, Color) = (1, 1, 1, 1) } SubShader { Tags { &quot;RenderType&quot;=&quot;Opaque&quot; } LOD 100 Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag // 开启多实例变量的编译选项 #pragma multi_compile_instancing #include &quot;UnityCG.cginc&quot; struct appdata { float4 vertex : POSITION; // 顶点着色器输入数据的 InstancingID 定义 UNITY_VERTEX_INPUT_INSTANCE_ID }; struct v2f { float4 vertex : SV_POSITION; // 片元着色器输入数据的 InstancingID 定义 UNITY_VERTEX_INPUT_INSTANCE_ID }; // 定义需要用到的多实例变量参数 UNITY_INSTANCING_BUFFER_START(Props) UNITY_DEFINE_INSTANCED_PROP(float4, _Color) UNITY_INSTANCING_BUFFER_END(Props) v2f vert(appdata v) { v2f o; // 装配 InstancingID UNITY_SETUP_INSTANCE_ID(v); // 输入到结构中并传给片元着色器 UNITY_TRANSFER_INSTANCE_ID(v, o); o.vertex = UnityObjectToClipPos(v.vertex); return o; } fixed4 frag(v2f i) : SV_Target { // 装配InstancingID UNITY_SETUP_INSTANCE_ID(i); // 提取多实例中当前实例的Color属性变量值 return UNITY_ACCESS_INSTANCED_PROP(Props, _Color); } ENDCG } }}" }, { "title": "Unity Hfsm", "url": "/posts/Unity-HFSM/", "categories": "", "tags": "", "date": "2022-07-01 00:00:00 +0800", "snippet": "UnityHFSM hierarchical finite state machine - 分层状态机 UnityHFSM安装 通过 [[OpenUPM]] 安装。openupm-cn add com.inspiaaa.unityhfsm创建状态机using FSM;public class EnemyController : MonoBehaviour{ private void Start() { // 创建一个状态机 StateMachine fsm = new StateMachine(); // TStateDefine 为状态ID的类型，可以是枚举等 StateMachine fsm = new StateMachine&amp;lt;TStateDefine&amp;gt;(); // Add State // Add Transition // 设置默认状态 fsm.SetStartState(&quot;FollowPlayer&quot;); // 初始化，必须在 OnLogic 之前调用 fsm.Init(); }}更新状态机private void Update(){ // 运行状态机 fsm.OnLogic();}状态查询private void TestFunc(){ // 获取现态 StateBase&amp;lt;string&amp;gt; state = fsm.ActiveState; string name = fsm.ActiveStateName;}Add StatesNormal States// 添加空状态(什么都不做的状态)fsm.AddState(&quot;Running&quot;);fsm.AddState(&quot;Running&quot;, new StateBase&amp;lt;string&amp;gt;(needsExitTime: false));fsm.AddState(&quot;ExtractIntel&quot;, new State());fsm.AddState(&quot;FleeFromPlayer&quot;, new State( onLogic: (state) =&amp;gt; MoveTowardsPlayer(-1))); fsm.AddState(&quot;FollowPlayer&quot;, new State( onLogic: (state) =&amp;gt; { MoveTowardsPlayer(1); }));CustomClass Statesfsm.AddState(&quot;FollowPlayer&quot;, new CustomSendData(this));// .....class CustomSendData : StateBase{ MonoBehaviour mono; // Important: The constructor must call StateBase&#39;s constructor (here: base(...)) // because it declares whether the state needsExitTime public CustomSendData(MonoBehaviour mono) : base(needsExitTime: false) { // We need to have access to the MonoBehaviour so that we can rotate it. // =&amp;gt; Keep a reference this.mono = mono; } public override void OnEnter() { // Write your code for OnEnter here. // If you don&#39;t have any, you can just leave this entire method override out. } public override void OnLogic() { this.mono.transform.eulerAngles += new Vector3(0, 0, 100 * Time.deltaTime); }}Coroutine StatesIEnumerator SendData(CoState&amp;lt;string, string&amp;gt; state){ while (state.timer.Elapsed &amp;lt; 2) { RotateAtSpeed(100f); // Wait until the next frame yield return null; } while (state.timer.Elapsed &amp;lt; 4) { RotateAtSpeed(-100f); yield return null; } state.timer.Reset(); // 如果 needsExitTime 设置为true, 必须通知 FSM 此状态可以安全退出 state.fsm.StateCanExit();}void Start(){ // ... extractIntel.AddState(&quot;SendData&quot;, new CoState( this, // Pass in the MonoBehaviour that should run the coroutine onLogic: SendData, needsExitTime: true )); // ...}Ghost StatesstateDiagram-v2 direction LR [*] --&amp;gt; Start Start --&amp;gt; Idle Start --&amp;gt; Patrol Ghost状态可以帮助组织状态和管理转换条件。fsm.AddState(&quot;Start&quot;, isGhostState: true);fsm.AddState(&quot;Idle&quot;);fsm.AddState(&quot;Patrol&quot;);fsm.SetStartState(&quot;Start&quot;);// If the distance to the player &amp;gt; 10, the fsm will transition to the Idle state.fsm.AddTransition(&quot;Start&quot;, &quot;Idle&quot;, t =&amp;gt; distanceToPlayer &amp;gt; 10);// Because the state machine reviews the transitions in the order they were added,// it will first check the first transition.// If the condition is false, the fsm will then try the second transition,// which is guaranteed to work.fsm.AddTransition(&quot;Start&quot;, &quot;Patrol&quot;);自定义状态机 Action 可以定义除了 OnEnter, OnLogic, OnExit 之外的任意状态机Action。 调用自定义Action，只有当前激活的状态定义了此 Action，才会运行这个Action。 每个状态每个Action类型至多只能定义一个。fsm.AddState( &quot;Running&quot;, new State() .AddAction(&quot;OnFixedUpdate&quot;, () =&amp;gt; { }) .AddAction&amp;lt;float&amp;gt;(&quot;OnHit&quot;, damage =&amp;gt; PlayHitAnimation(damage)) .AddAction&amp;lt;float, string&amp;gt;( &quot;OnDamage&quot;, ((float damage, string damageSource) data) =&amp;gt; { // ... }; ));private void FixedUpdate(){ fsm.OnAction(OnFixedUpdate);}private void Test(){ fsm.OnAction&amp;lt;float&amp;gt;(&quot;OnHit&quot;, 5); fsm.OnAction&amp;lt;(float damage, string damageSource)&amp;gt;(&quot;OnDamage&quot;, (2, &quot;Enemy&quot;));}Add TransitionsOnLogic Transitions - Direct 添加状态切换条件，每次调用 OnLogic 都会按照添加先后自动检查是否符合条件。 polling-based 两个状态之间的转换条件可以有多个。// 添加无条件转换fsm.AddTransition(&quot;Shoot&quot;, &quot;Reload&quot;);// 添加有条件切换fsm.AddTransition(new Transition( &quot;ExtractIntel&quot;, &quot;FollowPlayer&quot;, (transition) =&amp;gt; DistanceToPlayer() &amp;gt; ownScanningRange));fsm.AddTransition(new Transition( &quot;FollowPlayer&quot;, &quot;ExtractIntel&quot;, (transition) =&amp;gt; DistanceToPlayer() &amp;lt; ownScanningRange));fsm.AddTransition(new Transition( &quot;ExtractIntel&quot;, &quot;FleeFromPlayer&quot;, (transition) =&amp;gt; DistanceToPlayer() &amp;lt; playerScanningRange));fsm.AddTransition(new Transition( &quot;FleeFromPlayer&quot;, &quot;ExtractIntel&quot;, (transition) =&amp;gt; DistanceToPlayer() &amp;gt; playerScanningRange));// 多条件转换fsm.AddTransition(new TransitionAfter(&quot;MainMenu&quot;, &quot;Game&quot;, 10));fsm.AddTransition(new Transition(&quot;MainMenu&quot;, &quot;Game&quot;, t =&amp;gt; Input.GetKeyDown(KeyCode.Space)));Trigger Transitions - Direct event-based，只有在某个事件触发时才会检查是否满足。// 定义fsm.AddTriggerTransition(&quot;OnCollision&quot;, new Transition(&quot;Alive&quot;, &quot;Dead&quot;, t =&amp;gt; health &amp;lt; 0));fsm.AddTriggerTransition(&quot;OnHit&quot;, &quot;Alive&quot;, &quot;Dead&quot;, t =&amp;gt; health &amp;lt; 0);// 触发, 触发事件会沿着状态机的层次向下不断传递fsm.Trigger(&quot;OnCollision&quot;);Any Transitions - Global 相当于 Animator 的 Any Statefsm.AddTransitionFromAny( &quot;Dead&quot;, t =&amp;gt; (health &amp;lt;= 0));fsm.AddTriggerTransitionFromAny(&quot;OnHit&quot;, &quot;Dead&quot;, t =&amp;gt; (health &amp;lt;= 0));fsm.Trigger(&quot;OnHit&quot;);TwoWay Transitions - Direct// 条件为true时从A-&amp;gt;B, 条件为false时从B-&amp;gt;Afsm.AddTwoWayTransition(&quot;Idle&quot;, &quot;Shoot&quot;, t =&amp;gt; isInRange);// 满足条件之后2秒才切换状态// 可以防止距离在10的附近不断变化时，状态不断切来切去fsm.AddTwoWayTransition( new TransitionAfter(&quot;Idle&quot;, &quot;Chase&quot;, 2, t =&amp;gt; distanceToPlayer &amp;lt; 10));// 添加双向触发状态切换条件fsm.AddTwoWayTrigerTransition(&quot;OnCoinsChange&quot;, &quot;TooExpensive&quot;, &quot;Affordable&quot;, t =&amp;gt; coins &amp;gt; 100);fsm.AddTwoWayTriggerTransition(&quot;OnCoinsChange&quot;, new Transition(&quot;TooExpensive&quot;,&quot;Affordable&quot;, t =&amp;gt; coins &amp;gt; 100));No Transitions - Direct 如果当前状态 needsExitTime，则目标状态会变成 pending state。 如果请求了多个转换，但当前的状态还不能退出，只有最后的转换会发生。fsm.RequestStateChange(&quot;ExtractIntel&quot;);fsm.RequestStateChange(&quot;ExtractIntel&quot;, forceInstantly: true);条件触发顺序分层状态机 State 和 StateMachine 都继承自 StateBase，所以 StateMachine 也能被看作一个普通的状态。private void Start(){ // This is the main state machine fsm = new StateMachine(); // This is the nested state machine StateMachine extractIntel = new StateMachine(needsExitTime: false); fsm.AddState(&quot;ExtractIntel&quot;, extractIntel); extractIntel.AddState(&quot;SendData&quot;, new State( onLogic: (state) =&amp;gt; { // When the state has been active for more than 5 seconds, // notify the fsm that the state can cleanly exit if (state.timer.Elapsed &amp;gt; 5) state.fsm.StateCanExit(); // Make the enemy turn at 100 degrees per second RotateAtSpeed(100f); }, // This means the state won&#39;t instantly exit when a transition should happen // but instead the state machine waits until it is given permission to change state needsExitTime: true )); extractIntel.AddState(&quot;CollectData&quot;, new State( onLogic: (state) =&amp;gt; {if (state.timer.Elapsed &amp;gt; 5) state.fsm.StateCanExit();}, needsExitTime: true )); // A transition without a condition extractIntel.AddTransition(new Transition(&quot;SendData&quot;, &quot;CollectData&quot;)); extractIntel.AddTransition(new Transition(&quot;CollectData&quot;, &quot;SendData&quot;)); extractIntel.SetStartState(&quot;CollectData&quot;); // ...}" }, { "title": "Gc", "url": "/posts/GC/", "categories": "", "tags": "", "date": "2022-06-20 00:00:00 +0800", "snippet": "什么是GC 游戏运行的时候，数据主要存储在内存中，当游戏数据不再需要的时候，当前这部分内存就可以被回收，以便再次利用。内存垃圾指当前废弃数据所占用的内存，GC是指将废弃的内存进行回收，使其可以再次被使用的过程。 垃圾回收器只回收内存，不回收其他资源，如：数据库连接，文件句柄，网络端口，硬件设备等。GC原理 mark-and-compact算法，mark是指先确定所有可达对象，compact是指移动这些对象，使它们紧挨着存放。整个过程有点儿像磁盘碎片整理。终结器 Finalizer GC 负责为对象实例调用终结器。不能在编译时确定终结器的执行时间，唯一确定的是终结器会在对象最后一次使用之后的某个时间点调用。 确定性终结见：[[CS-using#自动释放资源]] 终结器很可能永远不会被调用。 终结器在对象被 GC 判定为不可达的某个时间点执行，执行后再将其从终结队列中删除，使其可以再次使用。 终结器不负责回收内存。终结器负责释放文件句柄之类的资源。 public class FileStream{ // 构造函数 public FileStream() {} // 声明终结器的语法和C++的析构器完全一致 ~FileStream() { // todo something }} 内存垃圾太多会导致的问题 GC调用越频繁，耗费CPU越多。 GC调用频繁，会导致内存命中率下降。 堆内存碎片会导致占用内存越来越大，GC操作更加频繁。GC触发时机 如果申请堆内存，堆内存不够，就会触发GC操作来回收闲置的内存。 各个平台会定时自动触发GC。主动触发一次GCSystem.GC.Collect();怎样减少GC 缓存对象，不要在 Update 中频繁GetComponent。 减少逻辑调用。每帧调用变成隔一秒调用等。 复用 List，缓存下来，使用 Clear 清空，而不是 new 一个新的。 使用对象池。 字符串使用要格外小心，text要赋值的字符串尽量做到最短，把变化的数值独立出来。 减少字符串的使用，如果字符串拼接操作比较多，使用 [[CS-StringBuilder]]。 正式版移除 Debug.Log()，它不但分配字符串，还不间断的往文件写数据。 不要使用 LINQ。 使用公用的静态成员对象。 减少装箱和拆箱。" }, { "title": "贴图映射", "url": "/posts/%E8%B4%B4%E5%9B%BE%E6%98%A0%E5%B0%84/", "categories": "", "tags": "", "date": "2022-05-20 00:00:00 +0800", "snippet": "UV坐标 即纹理坐标 UV：映射模型的蒙皮贴图 UV2：也叫2U，计算光照，映射光照贴图 UV3：为实时全局光照服务 UV4~UV8：程序可以自定义使用的UV数据UV展开纹素 纹素指纹理上的一个像素，比如512x512的纹理，U轴有512个纹素，V轴也有512个纹素。贴图采样 当物体离摄像机很近时，一个像素会对应纹理上很小的一部分，包含很少纹素。 当物体离摄像机很远时，一个像素会对应纹理上很大的一部分，包含很多纹素。 贴图上的纹素和屏幕上的像素无法做到一比一的对应关系。当一个像素覆盖的纹理区域比较大时，就不能简单的采样。用一个像素点(采样点)去采样一大片贴图，铁定会走样 (信号变化太快，采样速度跟不上变化的速度) 因此，采样贴图时需要对纹素进行插值计算。 Filter Mode 决定了采样时的插值方式。采样理论 在图形学中，采样无处不在。Sampling is ubiquitous in Computer Graphics. Pre-Filter than Sample 先滤波再采样 不能先采样后模糊，先采样后模糊得到的是模糊的采样。Frequency Domain - 频域 傅里叶变换：把函数展开成正弦与余弦函数的和。 Filtering = Getting rid of certain frequency contents = Averaging = Convolusion 高通（低频）滤波 ： 只有高频信号可以通过，低频信号被过滤掉。画面只留下边缘。 低通（高频）滤波： 只有低频信号可以通过，高频信号被过滤掉画面变得模糊。 Box Filter = Low Pass Filter = 把高频信号平均化Filter Mode - 滤波方式 纹理大小和像素大小很难匹配，采样纹理时会得到非整数的UV坐标，需要指定滤波方式完成采样。 随着采样次数的提高，画面越来越平滑，消耗的GPU也越来越多，要平衡好画质和性能开销。Nearest （Point） 最近采样，也可以理解成不采样。纹素与像素大小不一致时，直接把UV坐标取整，取位置最接近的纹素颜色值。采样1次。 这种方式只是寻找了位置最接近的纹素，不能保证连续性，即使使用 Mipmap，像素和纹素也不能得到很好的匹配。 这种采样方式会让画面表现的很锐利。Bi-linear 双线性插值。取要采样的纹素周围最近的4个纹素，这4个纹素在线性计算上的权重值为纹素与中心点的距离，把所有采样得到的纹素进行加权平均（模糊）后可得到最终的像素颜色。采样4次。 双线性采样比 Nearest 更平滑，更模糊，但双线性采样只选取纹素和像素之间大小最接近的那一层Mipmap Level进行采样。导致当像素大小匹配的纹素在两层Mipmap之间时，双线性采样在有些情况下的效果就不太理想。Tri-linear 三线性插值。在双线性采样的基础上对像素大小与纹素大小最接近的上下两层 Mipmap Level 分别进行一次双线性过滤（模糊），然后对在两层Mipmap纹理上得到的像素结果进行插值计算，最终得到合理的纹素。采样8次。 可以根据连续的层数查询，不需要四舍五入到整数（比如可以查1.8层 (Level 1.8)） 相比Bi-linear，无非多了一次查询和一次插值，开销不算太大（第一趟 s 第二趟 t 第三趟 D） 三线性采样的结果比 Bilinear 更平滑，更模糊。Aniso Filter 各向异性插值。随着等级的提高，采样次数也逐步提高，消耗的GPU也越来越多。 当要贴图的三维表面平行于屏幕时就是各向同性。当要贴图的三维表面与屏幕有一定角度的倾斜时就是各向异性。 各向异性采样，除了会把Mipmap因素考虑进去外，还会把纹理与屏幕空间的角度考虑进去。它会考虑一个像素对应到纹理空间中在U和V方向上与U和V的比例关系，如果U:V不是1:1，将会按比例在各方向上选取不同数量的点来计算最终的结果。 各向异性采样的结果最平滑。以比较大的角度查看纹理时，可以提高纹理的质量。Unity中的滤波方式 Aniso(tropic) Level 为各向异性等级。等级越高，对一张贴图的不同长宽比做的预计算越多。只有开启了 Mipmap ，Filter Mode 不使用 Point，该参数才会生效。Mipmap - 多级渐远纹理 Mipmap原意就是很多小图，是一种常见的纹理映射技术。原理是根据物体与摄像机之间距离的不同，分别使用不同分辨率的纹理贴图。 当物体离摄像机很远时，像素与纹素的比率变得非常小（物体上的某片元覆盖的纹素变得很大），这样采样会使瑕疵非常明显。 因为使用MipMap，物体远离摄像机时会选择更小分辨率的贴图，在绘制场景时能够节省不少GPU和内存之间传输数据的带宽，所以也能节省一部分性能。 开启MipMap，会预计算好所有等级的图，一共会引入 1/3 的额外存储量。Anti-aliasing - 反走样，抗锯齿 反走样，即对几何图元的边缘进行平滑处理。 Aliasing - 混叠 信号变化太快（频率太高），在时域/空域采样太慢（过疏）。就会产生混叠（Aliasing）现象，即画面出现锯齿状的边缘。几种不同的瑕疵Artifact Jaggies Moire Wagon wheel effectMSAA MultiSample Anti-Aliasing 多重采样抗锯齿。 把一个像素点拆分成NxN个点，利用box filter平均这NxN个采样点，计算该像素最终的颜色 MSAA运行在GPU上，代价是消耗更多的GPU算力和显存，不过，它并不会消耗任何CPU算力。DLSS [NVIDIA DLSS 深度学习超级采样 (DLSS) 技术 NVIDIA](https://www.nvidia.cn/geforce/technologies/dlss/) Deep Learning Super Sampling" }, { "title": "A星寻路算法", "url": "/posts/A%E6%98%9F%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/", "categories": "", "tags": "", "date": "2022-04-26 00:00:00 +0800", "snippet": "参考资料Amit’s A* PagesA星算法只是一个寻路算法，需要有配套数据结构支撑。寻路数据结构见：[[寻路导航网格]]A星算法 A星算法只选择当前步骤的最优路径，只关注当前的最优解，所以会忽视全局的最优解，走“弯路“是常有的事情。 A星是对 [[Dijkstra最短路径算法]] 的一种优化。 A星算法是一种启发式算法，由人工预先设定的估算距离作为启发信息辅助计算，搜索会变得更加高效。 平均时间复杂度为 $O(nlogn)$. 最差的情况需要从起点出发将所有格子走一遍，最后才找到目的地。 权重：对每个待选的点计算权重，并按照权重排序，权重最小的点被选中。讲解A星算法的步骤 先将起点周围的点加入候补队列（优先队列）中，在候补队列中找到与目的地权重最小的点，再把这个点推出来，并以这个点为基准继续向前探索，直到寻找到目的地为止。 权重 = 从起点S到该顶点的距离（方块左下）+ 该顶点距离G的估算值（方块右下）。 伪代码function find_path(s,e){ open = new List(); // 没有被取到过的点 close = new List(); // 已经被取过的点 open.add(s); // 从s点开始 close.add(s); // 将s加入close队列 for(!open.IsEmpty())// 重复遍历直到没有点可以取 { p = open.pop(); // 把最近的点推出来 if(p == e) { // 找到终点 break; } p1 = p.left(); // 取左边的点 p2 = p.right(); // 取右边的点 p3 = p.top(); // 取上面的点 p4 = p.down(); // 取下面的点 plist.add(p1); plist.add(p2); plist.add(p3); plist.add(p4); for(int i = 0 ; i&amp;lt;plist.Count ; ++i) { pp = plist[i]; if(null != pp &amp;amp;&amp;amp; pp.IsNotInClose()) { pp.f = dis(pp,e); if(pp.IsNotInOpen()) { pp.SetOpen(); // 设置为已经在open中 open.Add(pp); // 加入队列 } } } // p点已经被取过了 close.add(p); // open队列会不断的加入可以行走的点，排序会越来越慢 open.sort(); // 进行排序 }}优化方案 场景很大或者很多角色使用A星算法时，会消耗很多CPU时间，从而导致设备性能急剧下降。我们需要对A星做一些优化，从而保持好的性能。 open队列会不断的加入可以行走的点，当两点距离很长时，open队列会被塞入很多节点，会使排序速度越来越慢，这个步骤是不可避免的，问题的关键就在于：如何减少open队列中的元素个数，如何加快open队列的排序速度，如何减少搜索次数。 A星大部分时间都消耗在了open队列的排序上，所以对open队列的排序做优化是很重要的。离线缓存路径 路径不一样要实时计算，可以把一些常用的路径离线缓存下来。角色需要寻路时，查询距离起点和目的地最近的缓存路径（A-&amp;gt;B），再计算当前位置到路径起点的实时路径（C-&amp;gt;A），路径终点的位置到目的地的路径（B-&amp;gt;D）,这样把 C-&amp;gt;A,A-&amp;gt;B,B-&amp;gt;D拼起来，就组成了一个完整的从起点到目的地的路径。 AB两点通常称为导航点，只要角色附近能够找到导航点，就能直接取出路径直达目的地，节省了大量实时计算路径的时间。 可以在路径上设置一些距离不是太长的导航点，先做导航点寻路，把导航点间的路径连起来作为完整路径链使用。优化Open队列排序方法 使用[[小根堆]]优先队列数据结构存储open队列，不需要在每次循环结束时重新排序，而是在节点插入最小堆时对最小堆数据结构进行调整。 因为open队列在插入元素前一定是有序的，可以用二分查找算法代替最小堆排序。先使用二分查找算法找到插入的位置，再将元素插入队列，这样每次插入的时间复杂度是 $O(logn+n)$, 这样比快速排序一次的时间复杂度$O(nlogn)$要好一些。通过权重引导寻路方向 在网格中加入权重值来改变权重从而引导算法寻路走向。权重值小的格子可以组成快速通道 可以令权重 = 当前最近步数 + 当前点到终点的直线步数 + 格子的权重值。拆分寻路区域 把某个范围内的节点合并为一个区域，把整个地图分成N个大区域，相比于成千上万个格子作为寻路节点要好得多。有了大区域后，只需要寻找大区域间的路径就知道该怎么走，大大降低了搜索的算力。 必须保证拆分之后的可行走区域是凸型，这样区域内就不需要再寻路，任意两个点都是可达的。 - 栅格地图：只能是矩形区域。 - 三角形网格：以凸多边形为单位拆分。 寻路时以区域块为寻路网格，每个区域都记录与之连接的区域以连接点，当算法找到起点与目的地点的区域路径时，只要拼接邻接的路径点就能得出两点的真实路径。 下图为三角形网格用凸多边形划分的区域，s -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; e减少判断某节点是否被取用过的消耗 当我们查看一个节点是否被取过时，需要判断该节点是否close，有以下几种方法： 在close队列中查找 - 这种做法相当于遍历一次整个close队列，随着close队列里节点的增多，浪费的CPU也越来越多，并且是每次循环都会浪费一次，性能损失巨大。 把节点当成一个实例，添加IsClose变量判断是否被取过 - 这种方法每次寻路前都需要把所有节点都初始化一次，这样做就把A星算法节省下来的性能完全抵消掉了，因此最好不要初始化。 递增一个整形变量值标识是否被取用过 - 寻路类中设置一个全局属性 FindIndex 记录当前的寻路次数，每次寻路前都加一；节点类中也保存一个变量 FindIndex；判断节点时，如果全局和节点的 FindIndex 不同，说明此节点在本次寻路中没有被取用过；当节点被取出时，把节点的 FindIndex 设置成寻路类的 FindIndex，表明此节点被踩过了。(这是一个通用的技巧，任何需要遍历初始化为布尔量的逻辑都可以用此方法避免初始化开销) bool function IsClose(Point p){ returen p.FindIndex == AStar.FindIndex;} " }, { "title": "寻路导航网格", "url": "/posts/%E5%AF%BB%E8%B7%AF%E5%AF%BC%E8%88%AA%E7%BD%91%E6%A0%BC/", "categories": "", "tags": "", "date": "2022-04-25 00:00:00 +0800", "snippet": "2D数组构建网格 使用数组存储网格，其中的每个单元可以代表多种状态，比如 0 代表可行走，1 代表不可行走，2代表草地等等。 每个单元的尺寸需要与地图的大小对应起来，比如每个单元代表地图上的 10 米。要综合考虑地图的大小和障碍物的大小，来确定地图的匹配关系。如果单元格很大，无法实现细腻的路径与障碍；如果单元格很小，过大的数组会造成内存的浪费。邻接点 每个点的邻接点就是其周围的4个点或者8个点，与目的地的期望值可以通过计算方块之间的距离得到。几种编辑数组网格的方式： 使用 [[Excel]] 表。使用颜色或数字区分不同的单元格，导出到文件，游戏内读取。 使用 [[UnityEditor]] 制作地图编辑器。 在具体的3D场景中编辑地图。 使用贴图存储地图。其中每个像素代表一个区域，用Alpha值区分不同的类型，这样整张地图可以被压缩成只有A通道的8比特图。当加载数组作为可行走数据时，会加载该图片读取像素中的每个元素并录入内存中，然后根据内存中的二维数组判定是否是可行走区域，以及相邻的格子是否是障碍物。 存储在内存中时使用一维数组更好，仅仅在读取时多了个行偏移，但是大大提高了缓存命中率，加快了指令运算速度。缺点 场景特别大时，数组也会特别大，比较占用内存。 场景特别大时，编辑可行走区域的工作量也会特别多，还容易出错。 场景内障碍物分布不规则时，会在空旷的地方浪费掉很多内存。路点网格 路点系统弥补了数组形式的缺点，它由很多点构成，这些点连起来构成寻路网。寻路时根据A星算法计算出路径，沿路点的连线移动就能够到达终点。 路点系统要在既有的地图上编辑，需要有可视化的编辑器实现路点的编辑功能。邻接点 路点系统中点的邻接点就是与该节点有线条连接的点，与目的地的期望值可以通过计算点与点之间的距离得到。优点 路点的数量比其他方式的网格少很多，所以内存消耗和CPU消耗都比较少。缺点 当设置大范围的可行走区域时，需要大量的工作来编辑可寻路的路点信息和连线。 在大块空地寻路时，需要添加比较多的路点，才能平滑地适应各种寻路路径。 行走路线的平滑程度依赖于添加路点的密度。 路点系统的寻路方式无法识别障碍区域，行走的路线依赖于路点之间的连线2D平面三角形网格 三角形网格方式使用算法自动生成寻路网格，无需手动编辑就能避开障碍区域。三角形剖分算法[[切耳(Ear Clipping)算法]] 大多数项目中平面三角形网格已经够用，即使有起伏的地面寻路，可以采用2D寻路+Y轴射线碰撞检测地面的形式获得位置坐标。邻接点 平面三角形网格中的基本单位是三角形，其邻接三角形是与其共享边的三角形，与目的地的期望值可以通过计算三角形的中点与目的地之间的距离得到。三角形网格寻路方法 如果把三角形中点作为寻路路径点，会导致中点与中点的连线路径不够平滑，寻路路线会非常诡异。 可以考虑使用边的中点记录路径，因为相邻三角形之间的穿越都是靠邻边来实现的，所以邻边的中点更适合三角形穿越，这样比使用三角形中点得到的路径更平滑，但是依然会有很多折现。 使用射线优化路径算法，找到拐点，通过拐点拼接寻路路径，会减少很多折线。2D多层级网格 多层级网格需要把所有可行走区域分成多个层级，每一层都有自己的网格数据，每层数据可以分别使用数组网格或者平面三角形网格。 例如4层楼房，每一层都有自己的网格数据，在楼梯部分记录各层之间的连接点。 寻路时，每一层只关心自己的数据，如果要跨层寻路，就需要通过连接点。3D体素化寻路网格 为了支持3D高度上的自由寻路，引入“体素化”的概念，体素化是指将空间分割成一个个的立方体方块，每个立方体都标志着一种可行走状态，如果人物太高或者太宽，则角色就无法通过狭窄的门缝或者矮小的洞穴。Recast Navigation Navmesh Recast 是指把三角形网格表示的空间场景转化为可供寻路使用的导航数据（NavMesh）。Recast 大体流程 把场景网格体素化。即把空间分割成三维方块，每一块是一个立方体，标记了是否可以行走。 生成可行走的区域。整理体素，把不能行走的体素过滤掉，去除障碍物周围角色宽度的体素，整理剩下的体素连接成一个个的区域。 把区域拆分成多个凸多边形。检测划分区域的轮廓并构造成 [[简单多边形]]。再将轮廓分割成多个凸多边形。 生成三角形导航网格。对所有的凸多边形进行三角化，并且基于多边形中高低不平的地面部分插入顶点，构建三角形。" }, { "title": "平面三角形的剖分问题", "url": "/posts/%E5%B9%B3%E9%9D%A2%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E5%89%96%E5%88%86%E9%97%AE%E9%A2%98/", "categories": "", "tags": "", "date": "2022-04-23 00:00:00 +0800", "snippet": "概念 三角形作为最简单的平面图形，较其他平面图形在计算机表示，分析和处理等方便要方便的多。 平面三角形的剖分问题意思是在一张平面图上有很多颜色，颜色边界形成了很多点和线，根据这些点和线将这幅图分解成由许多三角形组成的多边形。 三角剖分是研究其他很多问题的前提。应用领域 模式识别 图像处理 计算机图形学 机器人领域Delaunay三角剖分算法 Delaunay三角剖分算法是一个准则，满足此准则的算法即同时满足全局和局部最优。 Delaunay三角剖分的三角形必须满足以下三个要求： 除了端点，三角形的边不包含其他任何点。 除了在点上的连接，没有任何一条边是相交的。 所有的面都是三角形，且所有三角形的合集是所有点集合的凸包。 Bowyer-Watson算法切耳(Ear Clipping)算法 切耳算法需要工作在 [[简单多边形]] 上。 耳点：指多边形中相邻的三个顶点V0、V1、V2形成的三角形里，不包含任何其他顶点，并且如果V1点是凸点，即V0-V1的连线与V1-V2的连线之间形成的夹角小于180度，则认为V1是耳点。所以，一个由4个顶点组成的多边形中，至少有2个耳点。 耳朵三角形：三角形顶点中有耳点的就叫耳朵三角形。 切耳算法的步骤： 第一，找到一个耳点。 第二，记录这个耳朵三角形，然后去掉这个耳朵点，基于剩余的顶点继续回到第一步。 第三，直到剩下的最后3个点形成一个三角形并记录下来，把所有记录的三角形拼接起来就形成了三角化网格。 按照切耳算法的规则，以下图可以按照65431的顺序选点，按照 ABCDE的顺序切分。" }, { "title": "渲染优化", "url": "/posts/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/", "categories": "", "tags": "", "date": "2022-03-06 00:00:00 +0800", "snippet": "渲染优化方法渲染面数太多 同屏三角面数最多 20 ~ 50万。整个场景面数太多，只会让内存上升，同屏展示的面数太多才会让GPU压力变大。 利用好CPU摄像机裁剪，摄像机外的模型尽量不让其进入渲染管线。 拆分模型中很大，很长的模型，不然露出一点点就会全部渲染，使摄像机裁剪失效。 使用 [[LOD]]，使远距离顶点减少。Batching合批用于解决DrawCall太多的问题。Drawcall最好保持在100上下。为了合批模型尽量使用相同的材质。重复性不高的小模型尽量合并。 [[SRP Batcher]] [[Static Batch]] - 把使用相同材质球的网格合成一个 [[Dynamic Batch]] - 把使用相同材质球的网格合成一个 [[GPU Instancing]] - 使用 GPU 一次画出多个网格（要求网格要使用相同的材质） [[Manual Combine]] - 手动把使用相同材质球的网格合成一个Shader太复杂 不要用太复杂的shader。 片段着色器中计算复杂逻辑会消耗更多的算力，因为片段着色器是针对每个像素进行计算的，而顶点着色器则是针对每个顶点进行计算的，两者的数量有很大的差别，如果我们能将片段着色器的计算量转移到顶点着色器中，就能节省很多GPU消耗。 使用复杂的数学函数也会导致性能开销大，比如pow、exp、log、cos、sin、tan等，如果能使用近似公式代替它们，就能为GPU节省很多开销。 少用shader变体。 控制shader精度。带宽不足 贴图太多，宽带压力大，[[显存]] 压力大。 选择合适的贴图压缩格式。 不需要勾 [[显存 read/write]]，就不要勾选，不然会占用双倍内存。 CPUCPU的工作 计算哪些物体需要渲染 物体必须处于摄像机的可视范围内才会渲染，哪怕只有一部分处于可视范围，仍然需要渲染整个物体 不在范围内的则剔除（cull） 将Mesh和Material等传送到 [[显存]]，以及设置渲染状态，调用图形API等 SetPassCall：CPU会发出更改指令，为将要渲染的物体设置渲染状态 SetPass Call 告诉 GPU 使用哪些设置去渲染网格。SetPass Call指令只有在渲染下一个网格的设置和渲染上一个网格的设置不一样时，才会发出 Draw Call：CPU通过 Draw Call 命令告诉 GPU，就按照上一次 SetPass Call 的渲染设置去渲染指定的网格CPU约束 CPU 约束，渲染过程中，CPU 为每一帧渲染准备数据花费的时间太长，导致渲染瓶颈 可以牺牲内存用于提高 CPU 性能CPU优化 减少Unity渲染对象的数量。 执行更严格的剔除。 使用Occlusion culling (内存+CPU换GPU) 减小远平面，这样远处的对象会落到视锥体外面。 更精细化的方法，把对象放到不同的层中，执行不同的剔除距离。Camera.layerCullDistances 减少Unity渲染每个对象的时间。 使用预烘焙光照贴图和预烘焙阴影。（构建时间+运行时内存+存储空间 换 运行时效率） 减少影响对象的per-pixel灯光的数量。 不使用实时阴影。 优化反射探针的使用。Reflection Probe performance GPUGPU的工作 GPU 按照 CPU 发送到 Command buffer 内的指令顺序处理 如果当前指令是 SetPass Call，那么GPU更新渲染状态 如果当前指令是 Draw Call，那么GPU根据上一次设置的渲染状态来渲染网格。GPU约束 GPU 约束，渲染数量过于膨大，导致 GPU 渲染一帧需要花费的时间过长 可以牺牲游戏画质解决渲染瓶颈GPU优化 如果瓶颈在填充率（想要画的像素数超出了GPU的处理能力） 透明贴图太多会导致 [[Overdraw]] 问题。 优化fragment shader。Shader Performance 使用URP的分辨率缩放。 如果瓶颈在内存带宽（GPU读写内存的效率超过了GPU的处理能力） 一般是因为贴图太多，或者贴图太大。 如果模型距离相机的距离有远有近，启用 [[Mipmap]]（内存换减少瑕疵） 使用合适的压缩格式 如果瓶颈在顶点处理。 优化vertex shader。Shader Performance 优化几何体，减少定点数，优化UV " }, { "title": "Unity渲染队列", "url": "/posts/Unity%E6%B8%B2%E6%9F%93%E9%98%9F%E5%88%97/", "categories": "", "tags": "", "date": "2022-03-01 00:00:00 +0800", "snippet": " 渲染顺序关注的是所有的 drawcall 以什么样的顺序渲染；每个网格谁先渲染，谁后渲染。 所有的网格先在CPU中排序，按照排好的顺序依次调用drawcall指令进入渲染管线进行渲染。 如果先渲染离屏幕近的物体，那么就能在ZTest的机制下早早地屏蔽掉后面地片元，提升GPU地效率。Unity渲染队列 每个物体进入不同的渲染队列，Queue值越小的越先渲染；每个队列中，按照距离摄像机的远近排序，其中：2500以下索引号的被认为是不透明物体，根据摄像机的距离由近及远地渲染（越早剔除越好）；2500以上索引号的被认为是半透明物体，根据摄像机的距离由远及近地渲染（为了正确的混合）。背景层 Background : Queue = 1000不透明物体 Geometry : Queue = 2000 不透明物体离摄像机近地排在前面渲染，远的放在后面渲染。半透明物体 Transparent : Queue = 3000 [[半透明物体]]需要混合，所以其渲染排在所有不透明物体之后。 为保证混合的正确性，半透明物体离摄像机远的先渲染。 半透明物体可以通过 Sorting Priority 改变渲染优先级。 如果两个物体的网格面片相交，或者同一个物体中的面片相互交错，则无法再区分片元的前后关系。原因是它们没有写入片元的深度值，即ZWrite为关闭状态，不能用深度值去判定片元是否覆盖或被覆盖；若为打开状态，则又会出现混合失效的情况，因为片元底下覆盖的片元被彻底抛弃，所以没有混合一说了。因此，使用Blend制作半透明物体，在复杂的半透明交叉情况下，通常很难做到前后关系有序。参考：[[渲染管线#深度测试 - Depth Test]] 如果把不透明物体放到半透明队列中，也会参与混合。覆盖层 Overlay : Queue = 4000" }, { "title": "光照烘焙", "url": "/posts/%E5%85%89%E7%85%A7%E7%83%98%E7%84%99/", "categories": "", "tags": "", "date": "2022-02-01 00:00:00 +0800", "snippet": "烘焙光照 烘焙光照就是预计算全局光照信息。 光照贴图中只记录间接光照，直接光照的计算代价不高，由着色器自己计算直接光照。 在一个场景中，如果这些物体只考虑直接光照的影响，则会缺乏很多光影细节，导致视觉效果很“平”。而间接光照则描述了光线在物体表面之间的折射，增加了场景中的明暗变化以及光线折射的细节，提高了真实感。 光照贴图使用UV2做贴图映射。 模型烘焙光照，会改写模型的UV2的数据。如果模型没有UV2的数据，可能无法得到正确的烘焙结果。Unity中的烘焙光照[[Bakery]][[Progressive]]烘焙贴图光照烘焙最多产生3种贴图。 光照贴图 阴影贴图 主光贴图和模型的UV2数据。UV Chart 在烘焙时，烘焙器会对所有场景中的静态物体上的网格进行扫描，按块大小和折线角度大小来制作和拆分网格上对应的UV块，这个UV块就是UV Chart。 UV Chart是静态物件在光照纹理上某块网格对应的UV区块，一个物体在烘焙器预计算后会有很多个UV Chart。因此每个物件占有光照贴图上的多个UV Chart，每个UV Chart为一段连续的UV片段。默认情况下，每个Chart至少是4×4的纹素，无论模型的大小，一个Chart需要16个纹素。UV Chart之间预留0.5个像素的边缘来防止纹理溢出。几种UV Chart Demo" }, { "title": "Mesh", "url": "/posts/Mesh/", "categories": "", "tags": "", "date": "2021-10-08 00:00:00 +0800", "snippet": "Mesh FBX 文件在Unity中会实例化成GameObject，MeshFilter 中的 Mesh 存储了网格的顶点，三角形索引，UV，顶点颜色，切线，法线，骨骼等渲染所需的必要数据。从头开始构建mesh 先设置顶点(vertices)，再设置三角形(triangles)。Vector3[] newVertices;Vector2[] newUV;int[] newTriangles;void Start(){ Mesh mesh = new Mesh(); mesh.vertices = newVertices; mesh.uv = newUV; mesh.triangles = newTriangles; GetComponent&amp;lt;MeshFilter&amp;gt;().mesh = mesh;}仅修改顶点属性, 不改变顶点数目 获取顶点属性，修改，重新设置到mesh中。private void Update(){ Mesh mesh = GetComponent&amp;lt;MeshFilter&amp;gt;().mesh; Vector3[] vertices = mesh.vertices; Vector3[] normals = mesh.normals; for (var i = 0; i &amp;lt; vertices.Length; i++) { vertices[i] += normals[i] * Mathf.Sin(Time.time); } mesh.vertices = vertices;}连续不断的增减三角形和顶点 先调用Clear清空整个mesh， 再设置顶点(vertices)和其他属性，最后设置三角形索引(triangles indices)。 Unity总是检查三角形索引看他们是否引用了数组外的顶点。调用Clear然后再设置顶点，最后设置三角形，可以确保三角形不会引用非法的数据。private Vector3[] vertices;private int verticesCount;private Vector2[] uvs;private int uvsCount;private int[] triangles;private int trianglesCount;private Mesh mesh;private void Awake(){ mesh = GetComponent&amp;lt;MeshFilter&amp;gt;().sharedMesh = new Mesh(); mesh.name = &quot;CustomMesh&quot;; vertices = new Vector3[128]; uvs = new Vector2[128]; triangles = new int[128];}private void Update(){ // Do some calculations... // update vertices, uvs, triangles... mesh.Clear(); mesh.SetVertices(vertices, 0, verticesCount); mesh.SetUVs(0, uvs, 0, uvsCount); mesh.SetTriangles(triangles, 0, trianglesCount, 0);}SubMesh Unity中所有的submesh存储在一个mesh中，materials中记录每个子网格用到的材质。 需要一个网格使用多个材质时就拆分成多个子网格，每个子网格赋予不同的材质。 每个子网格都有自己材质球，导致子网格越多，增加的 drawcall越多，且子网格无法与其他网格合并，导致优化的一个重要环节被阻断。 有时可以选择把网格完全拆分成其他网格来代替子网格。![[Pasted image 20221203145759.png]]这种不叫子网格，这种还是拆分好的独立的网格。MeshFilter MeshFilter 承载网格数据，Mesh 实例化后存储在 MeshFilter 类中。 MeshFilter 对 mesh 操作将生成新的网格实例，对 sharedMesh 操作将会改变与其他模型共同拥有的那个指定的网格数据实例。mesh &amp;amp; sharedMesh mesh 是实例型的变量，对mesh执行任何操作，都会额外复制一份后再重新赋值，即使只是get操作。 sharedMesh 是共享型变量，多个 3D 模型可以公用同一个指定的 sharedMesh，修改 sharedMesh，指向同一个 sharedMesh 的多个模型会同时发生变化。 优先使用 sharedMesh。MeshRenderer 一个 Renderer 只能渲染一个网格。 MeshRenderer 提取 MeshFilter 中的网格数据，用给定的 [[Material]] 绘制。 MeshRenderer 对 material 操作将生成新的材质实例，对 sharedMaterial 操作将会改变与其他模型共同拥有的那个指定的材质实例。material &amp;amp; sharedMaterial material 的工作原理类似 mesh，是实例型的变量。 sharedMaterial 的工作原理类似 sharedMaterial，是共享型变量。 优先使用 sharedMaterial。materials &amp;amp; sharedMaterials materials 和 sharedMaterials 可以针对不同的子网格。 material = materials[0] sharedMaterial = sharedMaterials[0]动态替换 sharedMaterials[0] sharedMaterials 的 get 方法返回的是一份拷贝的材质数组。 sharedMaterial 拿到的是 m_Materials 数组的第一个元素。 两者的 set 方法都是对整个数组进行重新赋值。Renderer renderer = gameObject.GetComponent&amp;lt;Renderer&amp;gt;();// 错误方法，不生效renderer.sharedMaterials[0] = newMat; // 正确赋值 materials &amp;amp; sharedMaterials 的方法Material[] arrMat = renderer.sharedMaterials;arrMat[0] = newMat;renderer.sharedMaterials = arrMat;// 单独赋值 material &amp;amp; sharedMaterial 也是生效的renderer.sharedMaterial = newMat;网格包围盒 AABB包围盒基本概念见：[[包围盒]]轴对齐包围盒// 本地空间的轴对齐包围盒mesh.bounds// 世界空间的轴对齐包围盒meshRenderer.bounds通过某包围盒扩大本包围盒Bounds b = new Bounds(Vector3.zero, Vector3.zero);b.Encapsulate(childMeshRenderer.bounds);编辑器中画出网格包围盒private void OnDrawGizmosSelected () { // A sphere that fully encloses the bounding box var center = renderer.bounds.center; var radius = renderer.bounds.extents.magnitude; // Draw it Gizmos.color = Color.white; Gizmos.DrawWireSphere (center, radius);}" }, { "title": "半透明物体的渲染", "url": "/posts/%E5%8D%8A%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E7%9A%84%E6%B8%B2%E6%9F%93/", "categories": "", "tags": "", "date": "2021-09-30 00:00:00 +0800", "snippet": "混合 - Blending 混合适用于半透明物体，只能在最后进行，因为之前的阶段，每个三角形，每个片元都是不认识的，没办法做混合。 混合过程：把当前片元的颜色值和帧缓存中的颜色值通过Apha值做计算。 混合方程：SrcColor×SrcFactor + DstColor × DstFactorAlpha Test Alpha Test 不使用混合，而是根据Alpha值进行裁切，即要么丢弃片元，要么留下片元。 Alpha Test 的物体可以放到不透明队列中，也可以放到半透明队列中渲染。Alpha Test的应用场景 Alpha Test 对只需要不透明和全透明的物体很有用。 叶子、小草，有细节的圆洞等，如果用网格来表达会多出很多面片，制作时间长，调整起来慢，同屏面数多。Alpha Test 使用纹理图片判断需要渲染的区域，可以很好的渲染这些物体。DemoShader &quot;Example Alpha Test&quot;{ Properties { _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; {} _Cutoff(&quot;Cut off&quot;,range(0,1))=0.5 } ... SubShader { ... // Alpha Test示例 Pass { struct v2f { float4 pos : SV_POSITION; float4 uv:TEXCOORD0; }; v2f vert(appdata_base v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); // 转换顶点空间 o.uv = v.texcoord; // 传递UV值 return o; } fixed4 frag(v2f i) : SV_Target { // 根据UV获取纹理上的纹素 fixed4 _color = tex2D(_MainTex,i.uv.xy); // clip函数检查参数是否小于0 // 如果小于0就discard fragment，否则就放过它 clip(_color.a - _Cutoff); return _color; } } } ...}" }, { "title": "渲染管线", "url": "/posts/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/", "categories": "", "tags": "", "date": "2021-08-20 00:00:00 +0800", "snippet": "渲染管线 渲染管线就是GPU完成一次绘制（Drawcall）的过程，经过此流水线的计算，最终将要渲染的画面输出到帧缓存上，最后在屏幕或RT上显示出来。 渲染管线关注的是每一个drawcall，或者说每一个网格是怎样通过流水线绘制出来的，最后混合时只需要和各种缓冲区（各种全屏缓冲区记录了各种渲染所需要的信息）进行比较，不需要关注其他网格或其他drawcall。 顶点着色器用于决定三角形应该放在屏幕什么位置。 片元着色器用于决定三角形范围内的片元拥有什么颜色。 混合决定最终屏幕像素的颜色值。应用阶段 - Application Stage1. 准备渲染需要的数据 包括决定渲染哪些模型，存在哪些光源，以及摄像头的位置等。 准备阶段还会做很多优化工作，从而节省渲染时间，提高性能。比如各种粗粒度的 [[Culling]] 剔除。 把渲染数据(网格或纹理等)加载到[[显存]]中；如果贴图已经存在显存中，不需要重复复制。把数据加载到显存中后，如果CPU不需要这些数据，就可以删除掉。2. 设置渲染状态 渲染状态就是一连串的开关或方法。如：是否开启混合，使用哪张纹理，使用哪个 [[Shader]]，是否背面剔除，使用哪些光源等等。 通俗的讲：设置渲染状态，就是设置并决定接下来的网格如何渲染。 CPU发送了渲染状态改变的指令后，需要控制总线将数据从CPU内存搬运到GPU内存，这个过程会耗费大量时间。 如果前后渲染的网格渲染状态完全相同，就不需要更改渲染状态。3. 调用 DrawCall DrawCall 就是CPU调用 [[图形API]] 向GPU发起的一条渲染指令。 这个指令指向本次调用需要渲染的图元（点，线，面）列表，不再包含其他渲染信息（之前的渲染状态设置步骤已经设置好了） 每个模型的每个材质球都会产生一次DrawCall，可以通过各种合批进行优化。 整个渲染命令队列中，渲染状态切换指令和 Drawcall 指令是交替出现的。 黑色表示完全可编程 实线表示必须由开发者实现的着色器 虚线表示可选的着色器 白色表示可配置 灰色表示由GPU固定实现，开发者无控制权几何阶段 - Geometry Stage 几何阶段内部也是个小型流水线。 几何阶段进行逐图元（点，线，三角形）的操作。1. 顶点着色器 Vertex Shader 顶点着色器通常用于实现顶点的空间变换，进行顶点着色等。 输入进来的每一个顶点都会调用一次顶点着色器。 顶点着色器本身不可以创建或者销毁任何顶点，而且无法得到顶点与顶点之间的关系。 [[顶点动画]] 就是在顶点着色器中改变顶点的位置，可以模拟水面，布料等。 [[3D烘焙动画]] 在顶点着色器中读取新的顶点位置。顶点着色器可以采样贴图） NDC 坐标：gl_position是归一化的裁剪(NDC)空间坐标，xyz各个维度的范围为-1到1，不带Viewport变换，只能在vertex shader中使用 顶点着色器把顶点坐标从模型空间变换到齐次裁剪空间。2. 曲面细分着色器 Tessellation Shader 可选着色器，用于细分图元。3. 几何着色器 Geometry Shader 可选着色器，可以用于产生更多的图元。4. 裁剪 Clipping 几何阶段的最后，由NDC坐标判断顶点是落在视口内，还是视口外。 完全在可视长方体内，数据传递给光栅化阶段。 完全在可视长方体外，剔除掉。 一部分在视野内，Clip裁剪掉视口外的部分，生成新的顶点连接边界处。5. 屏幕映射 Screen Mapping 此阶段负责把每个图元的NDC坐标转换到屏幕坐标。 屏幕映射得到的屏幕坐标决定了这个顶点对应屏幕上哪个像素（x,y）以及距离这个像素有多远（z）。 屏幕映射之后输出到光栅化阶段的信息有：顶点的屏幕坐标(x,y)，顶点的深度值(z)，顶点的法线方向等等。光栅化阶段 - Rasterizer Stage 光栅化阶段内部也是个小型流水线。 光栅化阶段有两个主要目标：计算每个图元(三角形)覆盖了哪些像素，以及为这些像素计算颜色。 光栅化就是屏幕空间的采样。 Rasterization = Sample 2D Positions 光栅化将屏幕坐标 (0,0) - (w,h) 离散化为一个一个的片元 Fragment (gl_FragCoord)三角形设置 - Triangle Setup三角形设置 三角形设置阶段从屏幕映射得到的信息有：顶点的屏幕坐标(x,y)，顶点的深度值(z)，顶点的法线方向等等。 三角形设置就是：通过上一阶段得到的三角形网格顶点的屏幕坐标，形成三角形的边，得到三角形边界的表示方式，计算每条边的像素坐标。即把三角形面片铺在屏幕空间坐标平面上。三角形设置(画线)算法 midpoint 中点算法 Bresenham 直线算法三角形遍历 - Triangle Traversal三角形遍历 三角形遍历也叫扫描变换（Scan Conversion）。 通过上一阶段得到的三角边，检查每一个三角网格分别覆盖了哪些像素，如果像素被覆盖，就生成一个片元（fragment）。像素插值 三角形遍历阶段使用三角形重心坐标对3个顶点进行插值，得到片元的信息。插值数据包括：屏幕坐标，像素深度，像素颜色，像素法线，像素UV坐标等。 可选的 Early-ZEarly-Z Early-Z是指在片元着色器之前做深度测试，丢弃掉测试不通过的片元。 如果不做Early-Z把被遮挡的片元剔除，则这些片元都要经过片元着色器的计算，可能很浪费性能。Early-Z 流程 Early-Z 通过GPU硬件自动实现。在正常的渲染之前通过一个超简单的pass（z-pre-pass）进行深度测试。 如果在片元着色器中主动抛弃片元（比如通过[[半透明物体的Alpha Test]]），Early-Z前置深度测试就会出现问题，因为Early-Z会把主动抛弃的片元后面的片元抛弃掉，画面中可能会留下黑洞，这样画面就不对了。 如果GPU检测到Fragment Shader中抛弃了片元或者修改了深度值，就会弃用Early-Z。片元着色器 Fragment Shader DirectX中叫做 Pixel Shader 像素着色器。片元着色器 逐片元执行 Fragment Shader 程序，片元彼此之间不相识。 片元着色器的输入是三角形遍历时根据从顶点着色器中输出的数据插值得到的。 片元着色器的输出是一个或多个颜色值。 片元着色器的功能主要有：纹理采样，改变颜色，计算光照，复杂着色，深度计算，丢弃片元等；最终输出一个像素颜色值。逐片元操作 - Per-Fragment Operations 在DirectX中，这一阶段被称为 输出合并阶段 Output Merger 此阶段的步骤大都可决定片元的去留问题，如果片元在这几个节点中的任意一个节点没有通过测试，管线就会停止并 discard 它，之后的测试就不会再继续执行；反之，测试全部通过，就会进入混合阶段混合，然后进入帧缓存等待输出到屏幕。多重采样的片元操作剪切测试 - Scissor Test模板测试 - Stencil Test 模板测试需要模板缓存（Stencil Buffer），它与屏幕缓冲区的大小一致，每个片元在测试时都会先取得自己位置上的模板缓冲位置并与之比较，在通过测试后才被写入模板缓存中，在整个渲染帧结束前它是不会被重置的，也就是说，所有的模板测试共享一个模板缓存块。深度测试 - Depth Test 深度测试的作用是根据深度来判断和覆盖帧缓冲中的片元。片元中有深度信息，来源就是在归一化坐标后三角形顶点z轴上的值，三角形经过光栅化后，三角内片元的深度是三个顶点的z坐标的插值，深度测试依靠这个深度来判定是否需要覆盖已经写进帧缓冲里的片元. 在判定过程中，深度测试有自己的缓深度存，即（Z-Buffer），它可读可写，就是为片元深度信息判定而存在的。深度测试使用的是像素深度值。 深度测试工作分为两块，其中一块为是否开启深度测试，即 ZTest，另一块为是否把片元深度值写入深度缓存，即 ZWrite。所有片元只有在ZTest中与深度缓存中的深度值进行比较，并被判定通过，才能够通过ZWrite写入深度值。 [[半透明物体]]应该关闭 ZWrite，打开 ZTest， 不然后面的片元会被抛弃，无法混合，因为不透明物体先渲染，所以不透明物体不会受到影响，但如果有多个半透明物体叠加渲染时，ZWrite 会导致后面的被抛弃，会让画面错乱。参考：[[渲染队列]]混合 - Blending 混合适用于半透明物体，只能在最后进行，因为之前的阶段，每个三角形，每个片元都是不认识的，没办法做混合。 混合过程：把当前片元的颜色值和帧缓存中的颜色值通过Apha值做计算。 混合方程：SrcColor×SrcFactor + DstColor × DstFactor显示画面 颜色缓冲区（Color Buffer） 双重缓冲（Double Buffering） 对场景的渲染写入后置缓冲（Back Buffer） 当前显示在屏幕上的图像位于前置缓冲（Front Bufer）其他 画家算法处理前后关系，剔除关系 不能处理互相交叉的情况 最大的缺点是，需要按照深度排序图元，非常非常慢。 Z-buffer（depth-buffer） Algorithm gl_FragCoord.z. [0,1] 显示深度图 float z = gl_FragCoord.z * 2.0 - 1.0; // [0,1] -&amp;gt; [-1,+1] float depth = (2.0 * near * far) / (far + near - z * (far - near)); depth = depth / far; // 非线性深度值 -&amp;gt; 线性深度值 gl_FragColor = vec4(vec3(depth), 1.0); " }, { "title": "Navmesh", "url": "/posts/NavMesh/", "categories": "", "tags": "", "date": "2021-08-08 00:00:00 +0800", "snippet": "新版组件式导航系统 新版的组件式导航系统，功能比原版导航系统更多，有空可以看看。Unity - Manual: NavMesh building componentsNavigation and PathfindingNavMesh组成部分 导航系统几大组成   NavMesh 导航网格，与具体的场景关联 NavMesh Agent 导航代理，挂载到需要导航功能的角色上 NavMesh Obstacle 动态障碍物 NavMesh OffMeshLink 导航链接，允许在不连通的区域之间建立链接 NavMesh 导航网格 Bake 的数据来源为 地形(Terrain) 或 网格 (Mesh)，不需要 Collider。 导航网格 Bake 使用的算法是[[平面多边形的三角剖分算法]]，其结果为用很多三角形表示的凸多边形平面。预定义Agent 打开 Window -&amp;gt; AI -&amp;gt; Navigation -&amp;gt; Agents，设置代理参数。定义导航区域 打开 Window -&amp;gt; AI -&amp;gt; Navigation -&amp;gt; Areas，定义导航区域。 例如，宁可绕一些远路也不要横穿沼泽，此时地形的Cost（代价）参数就派上用场了。如可以给草原区较低的Cost，而给沼泽和密林区较高的Cost。 A星等寻路算法在计算路径时会充分考虑通过每个区域的Cost，从而选择总Cost相对较小的导航线路。设置导航区域 把场景中与导航相关的静态 Terrain 或 Mesh 设置成 Navigation Static，包括地面，斜坡，楼梯，墙体，静态障碍物等。 打开 Window -&amp;gt; AI -&amp;gt; Navigation -&amp;gt; Object 选中场景中作为地面的 Terrain 或 Mesh，设置为 Walkable，勾选是否生成导航链接。 选中障碍物 Mesh，设置为 Not Walkable。 设置其他在 Areas 标签中定义好的 Areas。Bake导航网格 打开 Window -&amp;gt; AI -&amp;gt; Navigation -&amp;gt; Bake 设置好代理参数并Bake! Bake 好的网格数据保存在场景所在文件夹下的 NavMesh.asset 文件中。NavMesh API接口// 采样导航网格上距离目标点指定范围内的一个可行的点bool succeed = NavMesh.SamplePosition(targetPos, out var hit, patrolRange, 1);Vector3 wayPoint = hit.position;NavMesh AgentAgent和碰撞体 角色的碰撞体积一般用胶囊体表示，这个胶囊体的半径应该与代理半径一致或更小一些。 碰撞体半径大于代理半径，就可能出现导航系统认为能通过的窄路却被碰撞体阻挡的情况。 角色站立时有1.8米，下蹲后可以通过0.9米高的小洞，那么导航参数也应当考虑到角色下蹲移动的情况。Agent组件配置 为Agent角色，添加 NavMeshAgent 组件。 组件参数：Agent常用属性Agent API 接口// 设置目标点Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);if ( Physics.Raycast(ray, out RaycastHit hit)){ agent.destination = hit.point; }// 获取/设置当前速度agent.velocity = Vector.Forward;float v = agent.velocity.sqrMagnitude; // 向量长度的平方，速度快// 只是单纯比较向量之间的大小的话，建议使用Vector3.sqrMagnitude进行比较// 是否处于导航链接路径上，使用它判断是否需要播放跳跃动画agent.isOnOffMeshLink;// 获取/设置最大速率agent.speed = 2.5f;// 使agent停下来/重新活动agent.isStopped = false/true;NavMesh Obstacle 静态障碍物在 Bake 时就已经处理好，会在 NavMesh 上挖洞，不需要其他处理。 动态障碍物需要添加 NavMesh Obstacle 组件。动态障碍物影响导航的方式 阻碍模式：不勾选 Carve；障碍物对导航网格本身无影响，NavMesh Agent 会利用避障算法尽可能地规避它。优点是没有重新计算导航层的性能开销，性能好；缺点是障碍物较多较大时，效果可能不好。 阻碍方式适合有一定速度，体积不大的物体。 例如：角色过马路时路上的汽车等运动的小障碍。 打洞模式：勾选 Carve；障碍物会影响导航网格，在导航网格上“打洞”，Agent计算路径时会避开有洞的位置。 打洞方式适合静态的，运动频率特别低的物体。 例如：道路被掉落的石块堵死。 自动打洞模式：在勾选了 Carve Only Stationary 的前提下，当物体移动距离超过了 Move Threshold 的值则取消打洞；当物体的静止时间超过了 Time To Stationary 的值，就可以被看作暂时固定，切换到固定状态时会进行打洞。Off Mesh Link 导航链接是在 NavMesh 基础上添加路径或捷径。 例如：角色不用走楼梯下楼，可以直接从二楼跳下；角色可以直接跨越两个独立的NavMesh，走过 NavMesh 不连通的路径等。自动生成导航链接 打开 Window -&amp;gt; AI -&amp;gt; Navigation -&amp;gt; Object，选中场景中要生成导航链接的 Terrain 或 Mesh，勾选 Generate OffMeshLinks。 打开 Window -&amp;gt; AI -&amp;gt; Navigation -&amp;gt; Bake，设置 Agent 的 Drop Height（最大下落高度），Jump Distance（最远跳跃距离）。 重新 Bake 导航网格。手动生成导航链接 自动生成导航链接很方便，但不易控制，很容易生成大量链接。如果仅在个别地方需要链接，可以手动生成导航链接。 场景中新建一个空物体，添加 Off Mesh Link 组件，新建两个子物体分别作为链接的起点和终点。 Bi Directional - 是否为双向链接。导航与动画 设置 agent.velocity，使用速度的方向和大小来匹配移动动画。 使用 agent.isOnOffMeshLink，根据角色是否处于导航链接路径上，判断是否需要播放跳跃动画。注意事项 Agen抖动一般是因为目标不可达，检查一下是否地面以下有Bake的导航网格被覆盖掉了，使用SamplePosition采样一下目标点，再把目标传给Agent agent.radius = 0; 可以防止agent死亡后还阻挡玩家 [[刚体]] 和 NavMeshAgent 会有冲突, 同时挂载时要把 IsKinematic 勾上，使刚体称为运动学刚体，控制时调用NavMeshAgent的方法。" }, { "title": "网络同步方案", "url": "/posts/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/", "categories": "", "tags": "", "date": "2021-06-12 00:00:00 +0800", "snippet": "网络同步 网络同步方案不是互斥的，可以混合使用。同步方案的目标同步信息模拟其他玩家 网络同步方案的目标一是在多人游戏中用最少的信息同步量来逼真地模拟其他玩家的一举一动，让我们在玩游戏的时候能看到其他玩家的位置、动作及状态。这里的关键词是“模拟”，本地设备中获取的信息由于网络因素通常都是延后的，如何通过这些延迟的信息来模拟真实角色的位移、动作、特效，是整个方案的关键。确定同步的范围 不可能把所有玩家的状态都同步一遍，客户端和服务端都承载不了如此大的渲染压力和通信压力。所以需要通过某种方式确定同步信息的范围。常见同步方案 同步方案 适合游戏类型 游戏 状态同步 MMORPG,FPS 魔兽世界，吃鸡，传奇 实时广播同步 MMORPG,FPS 魔兽世界，吃鸡 帧同步 MOBA 王者荣耀 状态同步 状态即游戏角色的状态。为了能更逼真地模拟其他玩家的行为，把每个人的行为方式抽象成若干个状态。类似状态机，比如：攻击状态，追击状态，防御状态，奔跑状态，技能状态，寻路状态等等。客户端收到角色状态同步信息后，在一段时间内不需要其他信息就能模拟出这些角色的动作、位移及特效等。 这些状态都有一个共同的特点，就是只要我们给予所需的相同数据，就能展现出相同画面的个体效果。 整个状态同步过程中，服务端相当于幕后操纵者，客户端里的角色相当于木偶人。服务端通过发出指令控制客户端执行相关逻辑。优点 状态同步能够控制数据计算的安全性。 能够保证所有客户端的同步性。缺点 状态同步无法承受大量的数据。（位置和旋转的同步使用实时广播）实时广播同步 状态同步不能满足实时模拟不同玩家在游戏场景中的位置与旋转角度，这些信息需要实时更新。 状态同步和实时广播同步经常同时存在，状态同步用于更新时效性不是很强的信息，实时广播用于同步时效性强的信息（位置，旋转等）。 客户端每秒向服务器发送15~30次自身的位置、旋转和数据，再由服务器分发给其他玩家。在其他玩家收到位置、旋转信息后，根据收到的信息预测其当前的位置、速度、加速度、旋转速度和旋转加速度，并进行模拟和展示。服务器验证 实时广播一般要加上验证机制，不能让客户端为所欲为地决定自己的位置。常见应用 FPS - 玩家需要不停地移动自己的位置和朝向，以适应战斗的需要。 卡丁车 - 玩家要在高速移动的情况下不停地调整自己的方向和速度。 MMORPG - 玩家需要不停的改变自己的速度和旋转角度让战斗显得更加丰富和灵活。优点 能够实时预测模拟玩家的位置和速度。缺点 放弃对玩家数据的强校验，才能顺利和准确的模拟其他玩家的位置和旋转角度。帧同步 帧同步的逻辑不由客户端本身的逻辑帧Update决定，而是由网络收到的帧数据包驱动执行逻辑更新。 所有的逻辑更新都会放到收到帧数据包时的操作中，包括角色移动，攻击，释放技能等等。每当从服务器收到一个数据包，就会更新一帧或更新前面因延迟累积的帧数。 帧同步的服务器每秒向客户端发送15~30个帧数据包，即使没有任何信息，也会发送空帧数据包，因为客户端需要根据这些数据包演算游戏逻辑。 帧数据的集合可以认为是一条时间线，用帧代替秒计算时间，例如：某个动作做5帧而不是5秒，子弹飞行10帧而不是N秒。根据帧数据，可以演算整个游戏逻辑，称为可演算的。 帧同步使用[[定点数]]避免误差。常见应用 适合同步性和安全性要求都很高的游戏，这些游戏每一帧都很关键，一两帧的计算就可能决定双方的胜负，所以不能有分毫之差。 王者荣耀，拳王等。优点 能够做到移动和旋转的准确定位。 能够同步角色状态。 有比较强的同步校验。" }, { "title": "Animator", "url": "/posts/Animator/", "categories": "", "tags": "", "date": "2021-05-20 00:00:00 +0800", "snippet": "动画导入配置见：[[3D模型规范和设置]]Animator 组件Locomotion - 移位, 从一个位置移动到另一个位置Animator Override 如果两个Animator状态机完全相同，则可以创建Override Animator，如果不同则不可以。Root Motion 根骨骼动画 角色的动画和移动速度是很难完全匹配上的。 动画快移动慢，会感觉角色在走“太空步”；动画慢移动快，会感觉角色在“飘”。 根骨骼动画：人物的跑步，走路和攻击等动作直接控制角色位置，物体会根据动画自带的位移改变自身的位置，这个位移速度由动画设计师决定，直接记录在动画中，而非程序控制。 使用了根骨骼动画的游戏来说，角色控制器的编写思路也会发生变化。由于通过控制动画状态机就能控制角色的移动，那么直接移动角色位置的代码就需要删除或做出修改。启用根骨骼动画的前提条件 动画制作时带有位移和旋转信息。 导入动画FBX文件时，正确导入了根骨骼动画信息。[[3D模型规范和设置]] Animator 中勾选了 Apply Root Motion 选项。Apply Root Motion// 启用/禁用 根骨骼动画animator.applyRootMotion = true;// 在 OnAnimatorMove 函数中手动应用根骨骼移动private void OnAnimatorMove(){ animator.ApplyBuiltinRootMotion();}OnAnimatorMove OnAnimatorMove 在每帧的 Update 之后调用。 如果脚本中使用了 OnAnimatorMove() 函数，那么 Animator 组件Inspector面板中的 Apple Root Motion 选项会变成 Handled by Script。API 接口设置转换条件animator.SetBool(&quot;Ground&quot;, true);animator.SetFloat(&quot;VSpeed&quot;, rigidbody2D.velocity.y);animator.SetInt(&quot;Count&quot;, 5);animator.SetTrigger(&quot;Attack&quot;);直接播放某个状态动画 Play 接口在下一帧生效，下一帧切换到新的状态。 如果Play(当前状态)，接口不生效。 参考animator.Play(stateName) called multiple times in one frame has issue// 直接播放, 不能重新切换到当前状态animator.Play(&quot;Idle&quot;);// 从头播放，带 layer 和 normalizedTime 参数的版本能同状态切换animator.Play(&quot;Idle&quot;, 0, 0);// 从中间播放animator.Play(&quot;Idle&quot;, 0, 0.5f);// 如果在一帧里多次切换会有问题// 如果有这种需求，要解决这个问题，可以使用 Play(&quot;StateA&quot;, 0, 0);private void SwitchAnim(){ animator.Play(&quot;StateA&quot;); // animator 中记录下一帧将切换到 StateA 状态 animator.Play(&quot;StateB&quot;); // animator 中下一帧用 StateB 覆盖 aniamtor.Play(&quot;StateC&quot;); // 当前帧为 StateC，所以不生效，最后停留在 StateB}代码控制播放进度float normalizedTime = [0,1];animator.speed = 0;animator.Play(&quot;Dance&quot;, 0, normalizedTime);不同的动画同步播放private Animator animator;private static float normalizedTime = 0;private static Tween valueAnim;private void Start(){ valueAnim ??= DOTween.To( () =&amp;gt; normalizedTime, x =&amp;gt; normalizedTime = x, 1, 1) .SetLoops(-1, LoopType.Yoyo) .SetAutoKill(false) .SetEase(Ease.Linear); animator.speed = 0;}private void Update(){ animator.Play(&quot;Dance&quot;, 0, normalizedTime);}Animator 状态机[[有限状态机]]Parameters参数适用情况 类型 适合情况 bool 适合是否落地等状态 float 适合表示速度等连续变化的值，例如根据其值在idle，walk，run之间切换 int 适合表示第几种武器，攻击动作的第几段等 trigger 用于自动结束的一次性动作。例如扔东西，开启闸门 TranstionExit Time 退出时间，指在切换到其他动画之前，先要继续播放一段当前动画，然后再切换。 常用于一些不可直接中断的动画，例如，某些游戏的攻击收招、拔枪或收枪等动作，出于真实感或游戏机制的原因，必须确保动画完整播放完毕（退出时间设置成1），才能切换到另一个动画。 进入攻击状态时不需要退出时间，也不需要过渡时间，以便立即进入攻击状态。Transition Duration 过渡时间，指从状态A切换到状态B时，要经过一个“A+B”叠加状态的一段时间。 这段时间用于让两个动作完美过渡，例如在动作真实的3D游戏中，玩家角色从走切换到跑、从站立到跳跃，都需要一小段自然转换动作的时间。 2D序列帧动画不支持动画融合，即使加上过渡时间，也无法让动画系统自动计算插值过渡，最终玩家感受到的不过是“延迟”。Can Transition To Self 由 AnyState 切换到其他状态时，一般需要 Can Transition To Self。 AnyState -&amp;gt; Die， 不需要 Can Transition To Self。Blend Tree 应用 1D混合树可以根据速度切换Idle,Walk,Run动画 混合树示例Layers应用场景 使用Layer可以用来管理角色的不同身体部位。比如下半身用于行走或跑步，上半身用于射击或投掷物体。 也可以用来管理不同的状态时期，比如普通状态，攻击状态，死亡状态，每个状态下有自己的一套动作。这样分层不至于让状态机很乱。设置 Weight - 权重 表示本层对总体动画效果的影响，0代表没有影响，1代表完全影响。如果为 1 + Override 则100%覆盖其他的层。 Mask - 遮罩 可以按照 Avatar Mask 资源文件中的配置，让这一层里的所有动画都被遮罩所控制。例如：该层只负责上肢动画。对单个动画文件的遮罩设置见：[[3D模型规范和设置]] Blending - 混合模式 Override 指这一层覆盖其他层 Additive表示叠加到已有动画上 IK Pass - 是否更新IK 如果勾选，该层动画会触发脚本中的 OnAnimatorIK() 函数，可以在脚本中进一步处理IK。 制作额外Layer时，Entry可以首先进入一个Empty的状态，这样就不会影响其他的层。IK Pass Animator Layer设置中需要开启 [[IK]] Pass 功能。 所有开启了IK Pass的层都会调用脚本中的OnAnimatorIK()函数。与IK相关的函数只能在 OnAnimatorIK() 中调用，编写到其他地方不会起作用。头部IKprivate void OnAnimatorIK(int layerIndex){ // 设置IK运动权重，即IK干预动画的程度，设置注视目标的权重为1 // 权重为1为完全干预，权重为0相当于关闭了IK animator.SetLookAtWeight(1); // 设置注视的目标位置，一直注视 (0,0,0) 点 animator.SetLookAtPosition(new Vector3(0, 0, 0));}手脚IKprivate void OnAnimatorIK(int layerIndex){ // pos 是目标位置 animator.SetIKPosition(AvatarIKGoal.LeftHand, pos); animator.SetIKPositionWeight(AvatarIKGoal.LeftHand, 1); // rot 是目标朝向 animator.SetIKRotation(AvatarIKGoal.LeftHand, rot); animator.SetIKRotationWeight(AvatarIKGoal.LeftHand, 1);}Animator StateMachine Behaviour 通过Animator参数可以获得GameObject身上的所有组件。优化 一帧内同时更新的动画最好控制在30个以内。 UI上的Animator，如果动画比较简单，可以改用 [[DOTween]] 如果动画不需要产生位移，关闭 Apple Root Motion 动画的Inspector面板开启 Optimize Game Objects 选项，这样Unity在处理动画片段时，会移除Transform的层级信息，该设置对于Animators.Update的耗时提升都非常明显，可以极大程度上降低主线程的动画耗时。 AlwaysAnimate状态下，当角色在屏幕外时，仍会继续产生Update开销，将这个选项改为CullUpdateTransforms或CullCompletely。CullUpdateTransforms适用于动画会产生位移的Animator Controller，CullCompletely适用于动画不会产生位移的Animator Controller。常见问题 动画没有正常切换 如果有分层检查一下权重weight 如果状态机处于某个层，且该层weight为1，则其他层的动画不管怎样都不会播放 " }, { "title": "Unity中的截图方法", "url": "/posts/Unity%E4%B8%AD%E7%9A%84%E6%88%AA%E5%9B%BE%E6%96%B9%E6%B3%95/", "categories": "", "tags": "", "date": "2021-05-01 00:00:00 +0800", "snippet": "使用ScreenCapture工具类// 只能截全屏，不能针对相机，不能缩放string path = Application.persistentDataPath + &quot;/OneShot&quot; + Time.realtimeSinceStartup.ToString() + &quot;.png&quot;;ScreenCapture.CaptureScreenshot(path, superSize);利用 Texture2D读取屏幕像素int width = Screen.width;int height = Screen.height;// 读取屏幕像素并存成Texture2Dvar screenCapture = new Texture2D(width, height, TextureFormat.RGB24, false);// 读取屏幕像素信息并存储为纹理数据screenCapture.ReadPixels(new Rect(0, 0, width, height), destX, destY); // Rect定义截取的区域， 左下角为(0,0)，右上角为(width, height), destX,destY是偏移screenCapture.Apply();// 采样以缩小截图的分辨率int targetWidth = (int) (screenCapture.width * 0.2f);int targetHeight = (int) (screenCapture.height * 0.2f);var targetCapture = new Texture2D(targetWidth, targetHeight, screenCapture.format, false);Color[] rpixels = targetCapture.GetPixels(0); float incX=((float)1/screenCapture.width)*((float)screenCapture.width/targetWidth);float incY=((float)1/screenCapture.height)*((float)screenCapture.height/targetHeight);for(int px=0; px&amp;lt;rpixels.Length; px++) { rpixels[px] = screenCapture.GetPixelBilinear(incX*((float)px%targetWidth), incY*Mathf.Floor(px/targetWidth));}targetCapture.SetPixels(rpixels, 0);targetCapture.Apply();// 把Texture2D编码并存储byte[] bytes = targetCapture.EncodeToJPG();string path = Application.persistentDataPath + &quot;/ScreenShot&quot; + level + &quot;.png&quot;;System.IO.File.WriteAllBytes(path, bytes);报错ReadPixels was called to read pixels from system frame buffer, while not inside drawing frame.图片应该先在Camera渲染完，存进缓冲之后再ReadPixels。解决方法一： 使用协程，yield return new WaitForEndOfFrame(); 之后再ReadPixels解决方法二： 在OnPostRender() 里处理, OnPostRender()只有在相机下才会执行利用相机截图// RT的depth设置成0的话，渲染出的画面会有问题//指定相机渲染并存成Texture2D// 创建一个RenderTexture对象var rt = new RenderTexture(720, 1280, depth); // 临时设置相关相机的targetTexture为rt, 并手动渲染相关相机MainCamera.targetTexture = rt; MainCamera.Render();// 激活这个rt, 并读取屏幕像素信息并存储为纹理数据RenderTexture.active = rt; var screenCapture = new Texture2D(720, 1280, TextureFormat.ARGB32, false);screenCapture.ReadPixels(new Rect(0, 0, 720, 1280), 0, 0);screenCapture.Apply();// 重置相关参数，以使用camera继续在屏幕上显示 MainCamera.targetTexture = null;RenderTexture.active = null;Destroy(rt);// 采样以缩小截图的分辨率同2// 把Texture2D编码并存储同2" }, { "title": "序列帧动画", "url": "/posts/%E5%BA%8F%E5%88%97%E5%B8%A7%E5%8A%A8%E7%94%BB/", "categories": "", "tags": "", "date": "2021-04-20 00:00:00 +0800", "snippet": "序列帧动画 序列帧动画是事先准备好动画中的每一帧画面，然后依次播放。 序列帧动画适合卡通风格的2D游戏，特别是“像素风”，更是绝配。使用 AnimationClip[[Animation Clips]]使用 ShaderGraph使用 Shader 顶点着色器 先定义帧动画的总帧数、图元排列的行数和列数，以及播放速度，在顶点着色时就计算好UV，计算过程是通过当前的时间和速度及总帧数，获得当前所在的帧数，再用帧数计算图片所在的行位置和列位置，最后用行位置和列位置计算UV数据，UV数据传入片元后，片元着色器从图片中提取像素颜色，交给后面的步骤进行渲染。Shader “UVAni”{ Properties { _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; {} // 序列帧贴图 _Total (&quot;total&quot;, float) = 1 // 总帧数 _Rows (&quot;rows&quot;, float) = 1 // 图元行数 _Cols (&quot;cols&quot;, float) = 1 // 图元列数 _Fps (&quot;speed&quot;, float) = 1 // 播放速度 } SubShader { Pass { Tags { &quot;Queue&quot; = &quot;Transparent&quot; &quot;RenderType&quot; = &quot;Transparent&quot; } Lighting Off ZWrite Off Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; sampler2D _MainTex; float_Total; float_Rows; float_Cols; float_Fps; struct v2f { float4 pos : POSITION; float2 uv : TEXCOORD0; } ; v2f vert(appdata_base v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP,v.vertex); // 顶点3D坐标转换为屏幕2D坐标 float floorModTime = floor(fmod( _Time.y * _Fps, _Total)); // 获得帧数 float uIdx = fmod(floorModTime , _Cols); // 获得横坐标索引 float vIdx = _Rows - 1 - floor(floorModTime / _Rows); // 获得纵坐标索引 o.uv = float2(v.texcoord.x / _Cols + uIdx / _Cols, v.texcoord. y / _Rows + vIdx / _Rows); // 计算贴图中的UV位置 return o; } float4 frag(v2f i) : COLOR { float4 texCol = tex2D(_MainTex,i.uv); return texCol; } ENDCG } }}C#中修改Mesh顶点UV做序列帧动画float row = 4, col = 2;tileSize = new Vector2(0.5f, 0.25f);frameCount = 4;startIndex = 0 or 4;curIndex = Mathf.FloorToInt(time * speed % frameCount + startIndex);minUV_x = curIndex % row * tileSize.x;minUV_y = 1 - (Mathf.FloorToInt(curIndex / col) + 1) * tileSize.y;maxUV_x = minUV_x + tileSize.x;maxUV_y = minUV_y + tileSize.y;private float playSpeed; // 播放速度private float row; // 有多少行private float col; // 有多少列private List&amp;lt;FlipBookInfo&amp;gt; flipBookInfos;private bool isDirty;private float timeElapsed;private MeshFilter meshFilter;private Mesh flipBookMesh;private Vector3[] vertices;private int verticesCount;private Vector2[] uvs;private int uvsCount;private int[] triangles;private int trianglesCount;private Vector2 tileSize; // 每个tile的尺寸 [0~1]private void Update(){ timeElapsed += (Time.deltaTime * playSpeed); if (timeElapsed &amp;gt; 1) { // 计算当前时刻每个序列帧动画播放到了第几帧 foreach (var flipBookInfo in flipBookInfos) { int tileIndex = Mathf.FloorToInt(timeElapsed % flipBookInfo.frameCount + flipBookInfo.startIndex); if (tileIndex != flipBookInfo.curIndex) { flipBookInfo.curIndex = tileIndex; isDirty = true; } } } if (isDirty) { RefreshMesh(); isDirty = false; }}private void RefreshMesh(){ // 初始化 if (meshFilter == null) { Init(); } // 根据flipBookInfo 构建网格 foreach (var flipBookInfo in flipBookInfos) { // 拷贝 triangles 和 vertices var mesh = flipBookInfo.meshFilter.mesh; Transform trans = flipBookInfo.meshFilter.transform; for (int i = 0; i &amp;lt; mesh.triangles.Length; i++) { triangles[trianglesCount++] = mesh.triangles[i] + verticesCount; } for (int i = 0; i &amp;lt; mesh.vertices.Length; i++) { vertices[verticesCount++] = trans.TransformPoint(mesh.vertices[i]); } // 根据 curIndex 计算 UV float minUV_x = flipBookInfo.curIndex % row * tileSize.x; float minUV_y = 1 - (Mathf.FloorToInt(flipBookInfo.curIndex / col) + 1) * tileSize.y; float maxUV_x = minUV_x + tileSize.x; float maxUV_y = minUV_y + tileSize.y; uvs[uvsCount++] = new Vector2(minUV_x, minUV_y); // 左下 uvs[uvsCount++] = new Vector2(minUV_x, maxUV_y); // 左上 uvs[uvsCount++] = new Vector2(maxUV_x, maxUV_y); // 右上 uvs[uvsCount++] = new Vector2(maxUV_x, minUV_y); // 右下 } // 更新 Mesh flipBookMesh.Clear(); flipBookMesh.SetVertices(vertices, 0, verticesCount); flipBookMesh.SetTriangles(triangles, 0, trianglesCount, 0); flipBookMesh.SetUVs(0, uvs, 0, uvsCount); verticesCount = 0; trianglesCount = 0; uvsCount = 0;}private void Init(){ meshFilter = GetComponent&amp;lt;MeshFilter&amp;gt;(); flipBookMesh = meshFilter.sharedMesh = new Mesh(); flipBookMesh.name = &quot;FlipBook&quot;; vertices = new Vector3[64]; uvs = new Vector2[64]; triangles = new int[64]; tileSize = new Vector2(1 / col, 1 / row);}" }, { "title": "群体ai", "url": "/posts/%E7%BE%A4%E4%BD%93AI/", "categories": "", "tags": "", "date": "2021-04-12 00:00:00 +0800", "snippet": "群体决策有多种表现形式，如在战棋类游戏中，玩家与计算机对手都控制着多名角色。要让AI对玩家有一定挑战性，仅针对每一个AI角色编程是不够的，还需要有纵观全局的决策逻辑，可以称之为meta AI（元AI）或群体AI，如图11-32所示。简单来说，就是一个场外的AI物体也具有一个状态机，它代表的是全局性的状态，如全局待命、全局防御和全局进攻某个单位等。群体AI还有一些更简单的实现方法，例如，在很多潜入型游戏中，发现玩家的AI角色会在短时间内发出喊叫声，喊叫声会惊动一定范围内的其他AI也朝这个方向移动。这样并不需要设计复杂的群体AI，也能达到多个AI互相配合的效果。" }, { "title": "可演算式ai", "url": "/posts/%E5%8F%AF%E6%BC%94%E7%AE%97%E5%BC%8FAI/", "categories": "", "tags": "", "date": "2021-04-12 00:00:00 +0800", "snippet": "策略类游戏中非常常见。根据两边的阵容数据和一个随机数种子来演算出整场战斗的每个细节。应用 页游里的大部分自动对战。 卡牌游戏中的自动战斗。特点 可演算式AI的逻辑一定是确定性的，不能是模糊的，或者会随机改变的，或者随时间变化而变化的，同样的数据第一次计算和多次计算的结果必须是相同的，才能最终体现出可演算的特征。 可演算式AI大都会根据时间轴来演化游戏的进程，“时间轴”的概念在可演算式AI中是比较常见的。" }, { "title": "音频规范和设置", "url": "/posts/%E9%9F%B3%E9%A2%91%E8%A7%84%E8%8C%83%E5%92%8C%E8%AE%BE%E7%BD%AE/", "categories": "", "tags": "", "date": "2021-04-09 00:00:00 +0800", "snippet": "Unity导入Audio音频的设置与优化项 根据平台选择合理的音频设置，原始音频资源尽量采用未压缩WAV格式。 当实现静音功能时，不要简单的将音量设置为0，应销毁音频（AudioSource）组件，将音频从内存中卸载。长音乐 移动平台可以将音乐采样频率设置为22050Hz 大多数声音尽量采用Vorbis压缩设置，IOS平台或不打算循环的声音可以选择MP3格式， 对于长度较长的音效或背景音乐则采用Streaming模式，虽然会有CPU额外开销，但节省内存并且加载不卡顿短音效 对于简短、常用的音效，可以采用解码速度快的ADPCM格式（PCM为未压缩格式） 简短音效导入后小于200kb，采用Decompress on Load模式 对于复杂音效，大小大于200kb，长度超过5秒的音效采用Compressed In Memory模式Unity 音频组件Audio Clip 音乐剪辑导入配置：[[音频规范和设置 Audio Clip Importer]] Audio Source Audio Source 组件用于播放音频片段。 同一个 Audio Source 同一时刻只能播放一个音频片段。Audio Listener 整个场景只能有一个 Audio Listener，默认挂载在主摄像机上。" }, { "title": "Fsm", "url": "/posts/FSM/", "categories": "", "tags": "", "date": "2021-03-15 00:00:00 +0800", "snippet": "好用的FSM插件UnityHFSMNodeCCanvasFSM FSM本质上只是机械化的程序逻辑，只需要最基本的分支语句就可以实现。 设计FSM的难点在于针对需求设计状态转移图，并设计精确的从一个状态转移到另一个状态的条件。只有有了清晰的状态转移图，才可能用明确的代码描述规则。状态和条件当前处于某个状态，如果发生某件事，就切换到另一个状态。 现态：当前所处的状态 条件：条件满足时会触发一个动作，或迁移到次态。 动作：条件满足后执行的动作，非必须。 次态：条件满足后要迁往的新状态，次态被激活后就变成“现态”。状态机的应用所有能够构成独立状态的系统或功能，都可以使用状态机来表示。 游戏框架设计。 场景切换。 游戏AI - 空闲，巡逻，平静，激怒等 宝箱，机关等多动画的元素。例如：把宝箱或机关的每个动画看成一个状态 - 打开，关闭等。 [[C#迭代器]] [[动画状态机]]AI状态机AI状态机框架伪代码框架伪代码// 状态基类class AIStateBase{ private int STATE; public abstract OnEnter(); public abstract OnExit(); public abstract Update();}// 继承基类实现状态类class AIRunState : AIStateBase{ public AIRunState() { STATE = STATE.AIRunState; } public override OnEnter() { PlayAnimation(&quot;run&quot;,loop); } public override OnExit() { StopAnimation(&quot;run&quot;); } public override Update() { if(target != null) { MoveTo(target); // 如果有目标，则向目标移动 } else { Move(dir); // 如果没有目标，则向指定方向移动 } }}// 状态机控制类// 控制类管理各个状态类，控制各个状态之间的切换，相当于状态机的大脑。class StateControl{ AIStateBase[] mStates; AIStateBase mCurrentState; // 初始化 public void Init() { mStates = new AIStateBase[STATE.Max]; mStates[STATE.AIIdleState] = new AIIdleState(StateControl); mStates[STATE.AIRunState] = new AIRunState(StateControl); mStates[STATE.AIMoveAttackState] = new AIMoveAttackState(StateControl); mStates[STATE.AIPatrolState] = new AIPatrolState(StateControl); mCurrentState = null; } // 切换状态 public void ChangeState(STATE state) { if(mCurrentState != null) { mCurrentState.OnExit(); } mCurrentState = mStates[state]; mCurrentState.OnEnter(); } // 实时更新 void Update(){ if(mCurrentState != null) { mCurrentState.Update(); } }}AI状态机状态示例跑步 Run 用OnEnter函数编写机器人跑步的动画，并让动画不断循环播放，然后在更新函数Update中开启不断向前移动的位置变化动画。当机器人不再需要移动时，也就是退出跑步状态事件，OnExit既可以调用停止播放动画的方法，也可以不停止播放，因为下一个状态肯定会播放其他动画，不如让它们通过插值过渡一下，让动画看起来更顺滑。追击 MoveAttackState 进入OnEnter函数时先锁定目标，把目标保存下来，并且寻找追击目标的路径（Path Find）。接下来就是“追击状态”的更新函数，每帧都会调用更新函数Update。在Update函数中，检查目标是否已在攻击范围内，如果在范围内，则立刻播放攻击动画，并且调用目标的攻击接口来攻击目标，如果不在范围内，则检查锁定目标是否超出检测范围，如果确定已超出范围，则重新寻找路径，并且根据路径来完成位移，否则不再追击。整个追击状态都是在Update函数中不断地进行判断和位移。巡逻 Patrol 进入OnEnter函数，在OnEnter里找到一个最近的巡逻点，然后在更新函数Update中持续循环，走向最近的巡逻点，在走到第一个最近的巡逻点后，继续按照巡逻点的布置顺序前往下一个巡逻点，如此不断循环往复。同时每次更新移动时，都要检查敌人是否在范围内，如果有敌人出现在检查范围内，则结束当前巡逻状态，调用OnExit，转而进入追击状态。状态机的优缺点优点 可维护强。 可扩展性强。 逻辑耦合清晰。 符合人类思维逻辑，代码容易理解。 理论上来说 FSM 可以实现任何 AI 行为。缺点 每个状态都必须由设计人员亲自设定，因此编写每个状态时要考虑所有情况，每种情况要有相应的处理方式。 根据图论，增加顶点时，连线数会以平方的量级增加。所以AI过于复杂时，编写的逻辑复杂度呈指数级增长。最后很可能无法承受太复杂的AI行为逻辑。 复杂到一定程度，人脑就无法承受，所以只能实现一些低能或者低阶的 AI。 状态间的连线太多很容易让人陷入困惑。" }, { "title": "Android打包相关", "url": "/posts/Android%E6%89%93%E5%8C%85%E7%9B%B8%E5%85%B3/", "categories": "", "tags": "", "date": "2021-03-03 00:00:00 +0800", "snippet": "什么是 NDK？ NDK - Native Development Kit NDK是Android的一个开发工具包，可通过 NDK ，使用 JNI 与 Native（C，C++）代码交互。 在 [[Android-SDK]] 开发环境中，通过 NDK 实现 JNI （Java Native Interface） 的功能。Android的UI线程 UI线程就是主线程. 不要在UI线程执行任何耗时操作. 必须在UI线程访问UI控件. C++/C#/Java之间交互,牵扯到状态的更改,都要在UI线程中执行。 Unity和Android互操作 Unity和 [[Android-SDK]] 互操作的方法。Unity调用Android方法// 获取当前的ActivityjavaClass = new AndroidJavaClass(&quot;com.unity3d.player.UnityPlayer&quot;);currentActivity = javaClass.GetStatic&amp;lt;AndroidJavaObject&amp;gt;(&quot;currentActivity&quot;);// 获取特定的ActivitymainActivity = new AndroidJavaClass(&quot;com.feamber.sdk.MainActivity&quot;);// 调用Static方法mainActivity.CallStatic(&quot;ShowBanner&quot;, &quot;Main&quot;); // 方法名后为参数int value = mainActivity.CallStatic&amp;lt;int&amp;gt;(&quot;GetInt&quot;, key); // 泛型参数为返回类型// 支持方法重载，下面两个可以同时存在mainActivity.CallStatic(&quot;TASDKUserAdd&quot;, string, float);mainActivity.CallStatic(&quot;TASDKUserAdd&quot;, Map&amp;lt;string,string);Android调用Unity方法UnityPlayer.UnitySendMessage(&quot;AdsHandler&quot;, &quot;OnRewardVideoWatched&quot;, &quot;&quot;);// 场景中的游戏对象GameObject 方法名 参数Unity中通过Dictionary创建Java的HashMappublic static AndroidJavaObject DicToMap(Dictionary&amp;lt;string, string&amp;gt; dictionary){ if(dictionary == null) { return null; } AndroidJavaObject map = new AndroidJavaObject(&quot;java.util.HashMap&quot;); foreach(KeyValuePair&amp;lt;string, string&amp;gt; pair in dictionary) { map.Call&amp;lt;string&amp;gt;(&quot;put&quot;, pair.Key, pair.Value); } return map;}AndroidJavaObject map = DicToMap(param);mainActivity.CallStatic(&quot;CustomEventWithParams&quot;, eventId, map);启动和关闭Activity// 启动ActivityIntent intent = new Intent(LoginActivity.this, HomeActivity.class);startActivity(intent);// 关闭Activityfinish();显示对话框(Dialog) private boolean showPrivacyDialog() { Log.d(TAG, &quot;showPrivacyDialog: &quot;); if (SpUtil.getInstance().getBoolean(Constant.PRIVACY_PASS, false)) { return false; } AlertDialog.Builder builder = new AlertDialog.Builder(mActivity); builder.setTitle(&quot;温馨提示&quot;); builder.setMessage(R.string.privacyDesc); builder.setNegativeButton(&quot;不同意&quot;, null); builder.setPositiveButton(&quot;同意&quot;, null); builder.setCancelable(false); AlertDialog dialog = builder.create(); // 设置按钮颜色 dialog.setOnShowListener(new DialogInterface.OnShowListener() { @Override public void onShow(DialogInterface dialogInterface) { dialog.getButton(AlertDialog.BUTTON_NEGATIVE).setTextColor(Color.GRAY); } }); dialog.show(); // show之后设置回调，防止点击按钮之后Dialog自动关闭 dialog.getButton(AlertDialog.BUTTON_NEGATIVE).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Log.d(TAG, &quot;onClick: negative&quot;); ToastHelper.showTextBottom(mActivity, &quot;点击同意才可以继续游戏&quot;); } }); dialog.getButton(AlertDialog.BUTTON_POSITIVE).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Log.d(TAG, &quot;onClick: positive&quot;); VivoUnionSDK.onPrivacyAgreed(mActivity); SpUtil.getInstance().putBoolean(Constant.PRIVACY_PASS, true); applyPermission(); dialog.dismiss(); } }); // 设置使链接可点击 ((TextView)dialog.findViewById(android.R.id.message)).setMovementMethod(LinkMovementMethod.getInstance()); return true; }Android存档系统package com.mobilekit.utils;import android.content.Context;import android.content.SharedPreferences;import java.util.Map;public class SpUtil { private Context mContext; private SharedPreferences mSP; // 单例，延迟初始化 private static class Holder { private static SpUtil sInstance = new SpUtil(); } private SpUtil() {} public static SpUtil getInstance() { return Holder.sInstance; } public void init(Context context) { mContext = context; mSP = mContext.getSharedPreferences(&quot;mobileKit&quot;, Context.MODE_PRIVATE); } public void putBoolean(String key, boolean value) { mSP.edit().putBoolean(key, value).apply(); } public boolean getBoolean(String key, boolean defaultValue) { return mSP.getBoolean(key, defaultValue); } /** * 保存数据 */ public static void put(Context context, String fileName, String key, Object obj){ SharedPreferences sp = context.getSharedPreferences(fileName, context.MODE_PRIVATE); SharedPreferences.Editor editor = sp.edit(); if (obj instanceof Boolean) { editor.putBoolean(key, (Boolean) obj); } else if (obj instanceof Float) { editor.putFloat(key, (Float) obj); } else if (obj instanceof Integer) { editor.putInt(key, (Integer) obj); } else if (obj instanceof Long) { editor.putLong(key, (Long) obj); } else { editor.putString(key, (String) obj); } //apply()是异步写入数据 editor.apply(); //commit()是同步写入数据 //editor.commit(); } /** * 获取指定数据 */ public static Object get(Context context, String fileName, String key, Object defaultObj) { SharedPreferences sp = context.getSharedPreferences(fileName, context.MODE_PRIVATE); if (defaultObj instanceof Boolean) { return sp.getBoolean(key, (Boolean) defaultObj); } else if (defaultObj instanceof Float) { return sp.getFloat(key, (Float) defaultObj); } else if (defaultObj instanceof Integer) { return sp.getInt(key, (Integer) defaultObj); } else if (defaultObj instanceof Long) { return sp.getLong(key, (Long) defaultObj); } else if (defaultObj instanceof String) { return sp.getString(key, (String) defaultObj); } return null; } /** * 删除指定数据 */ public static void remove(Context context, String fileName, String key) { SharedPreferences sp = context.getSharedPreferences(fileName, context.MODE_PRIVATE); SharedPreferences.Editor editor = sp.edit(); editor.remove(key); //editor.commit(); editor.apply(); } /** * 返回所有键值对 */ public static Map&amp;lt;String, ?&amp;gt; getAll(Context context, String fileName) { SharedPreferences sp = context.getSharedPreferences(fileName, context.MODE_PRIVATE); Map&amp;lt;String, ?&amp;gt; map = sp.getAll(); return map; } /** * 删除所有数据 */ public static void clear(Context context, String fileName) { SharedPreferences sp = context.getSharedPreferences(fileName, context.MODE_PRIVATE); SharedPreferences.Editor editor = sp.edit(); editor.clear(); //editor.commit(); editor.apply(); } /** * 检查key对应的数据是否存在 */ public static boolean contains(Context context, String fileName, String key) { SharedPreferences sp = context.getSharedPreferences(fileName, context.MODE_PRIVATE); return sp.contains(key); }}显示Toast提示package com.mobilekit.utils;import android.content.Context;import android.view.Gravity;import android.widget.Toast;public class ToastHelper { private static String oldMsg; private static long displayTime; public static void showTextBottom(Context context, String msg) { if (!msg.equals(oldMsg) || System.currentTimeMillis() - displayTime &amp;gt; 2000) { Toast.makeText(context, msg, Toast.LENGTH_SHORT).show(); displayTime = System.currentTimeMillis(); } } public static void showTextMiddle(Context context, String msg) { if (!msg.equals(oldMsg) || System.currentTimeMillis() - displayTime &amp;gt; 2000) { Toast toast = Toast.makeText(context, msg, Toast.LENGTH_SHORT); toast.setGravity(Gravity.CENTER, 0, 0); toast.show(); } }}读取Xml内容 一个在Android-Activity中读取 [[XML]] 值的Demo// string.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;resources&amp;gt; &amp;lt;string name=&quot;privacyDesc&quot;&amp;gt;欢迎进入游戏！为了保护您的隐私和使用安全，请您务必仔细阅读我们的 &amp;lt;a href=&quot;https://crazycooking.vrcoolgame.com/vrcoolgame/conditioncn.html&quot;&amp;gt;《用户协议》&amp;lt;/a&amp;gt; 和 &amp;lt;a href=&quot;https://crazycooking.vrcoolgame.com/vrcoolgame/privacycn.html&quot;&amp;gt;《隐私政策》&amp;lt;/a&amp;gt;。 我们希望通过这些条款，向您说明在使用我们的产品时，我们如何使用、保存和管理这些信息。 您点击同意的行为即表示您已经阅读完毕并同意上述协议和政策种的全部内容。 如您有任何问题、意见或投诉，请与我们联系。&amp;lt;/string&amp;gt;&amp;lt;/resources&amp;gt;// 取得resIDbuilder.setMessage(R.string.privacyDesc);// 取得string值Html.fromHtml(getString(R.string.privacyDesc));" }, { "title": "地图编辑器", "url": "/posts/%E5%9C%B0%E5%9B%BE%E7%BC%96%E8%BE%91%E5%99%A8/", "categories": "", "tags": "", "date": "2021-02-03 00:00:00 +0800", "snippet": "地图编辑器的功能 规划和构建可行走区域和障碍区域。生成导航网格。可以使用不同颜色的多边形展示不同的区域。 地形与物件编辑。 游戏逻辑配置 - 关卡，触发器，事件，怪物出生点等业务逻辑的参数配置等。地形编辑定制式地形 直接制作模型。直接把网格作为地形放置在场景中，再给网格加上MeshCollider（一般再加个简模）作为碰撞。 使用地形系统。[[Unity-Terrain]] 内置的地形系统可以使用高度图存储。程序拼接 2D地图分成一个一个格子，程序动态 生成，只需要一个网格+设置UV，就可以在一个Drawcall中绘制整个地图。 暗黑破坏神的地图拼接。 程序拼接的地形需要合并模型，合批Drawcall，提高性能。物件编辑 物件以预制体的形式存在，以坐标、旋转角度、缩放大小为基准形成数据。 可以按以下代码存储地图中物件的数据：struct map_unit{ position, // 坐标 rotation, // 旋转角度 scale, // 缩放 type, // 类型 table_id, // 配置表ID size, // 大小 function_type, // 功能}地图加载方式 地图编辑器的主要作用是对场景地图进行编辑，且它有一个地图数据文件可供前后端使用。可视化体验良好的地图编辑器能够更好地帮助场景设计师、关卡设计师编辑更好、更绚丽、更好玩的地图场景。有了地图数据，才能更有序地在游戏中实例化地图场景，在加载地图时也才有更明确的目标。 从地图数据到场景还原都是通过加载资源实例化的方式进行的。直接加载整个场景 最简单，只需要根据地图数据文件把所有数据反序列化到内存，针对每个元素，加载它们所指定的模型或效果资源，并实例化到指定位置，设置旋转和缩放，或进行其他的一些操作。 如果场景简单，使用一次性加载，甚至可能不需要地图编辑器，只需要一个 prefab就能搞定整个场景。按需异步加载场景 如果场景很大，内容很多，全部加载到内存就会浪费掉大量内存和CPU，制作一个编辑器能帮助我们拆分地图中的元素，按需加载物件，节省不必要的内存和CPU开销。 按需加载，边玩边加载不会阻塞游戏很长时间，异步加载缓解了CPU在某个瞬间的消耗，体验会更好。大地图无缝加载 把世界按照格子划分，以角色为中心加载周围8个块的内容，角色移动时，加载玩家周围新的格子，卸载离开的格子。 九宫格之外的场景用迷雾，面片背景等遮挡住。 加载时同步和异步相结合使用，关键部分如地形，碰撞，主要模型等使用阻塞加载让玩家能立刻看到；其他物件使用异步加载并由近及远的顺序加载，使体验更加平滑。" }, { "title": "2d蒙皮骨骼动画", "url": "/posts/2D%E8%92%99%E7%9A%AE%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/", "categories": "", "tags": "", "date": "2021-01-29 00:00:00 +0800", "snippet": "2D骨骼动画 2D动画也可以借用骨骼动画技术。思路是，将2D角色身体的各个部分切割开，做成独立的图片，如头、胸、腹、臂和腿等，然后绑定一个2D的“火柴”组成的骨骼，通过调整骨骼，也可以让2D角色活灵活现地动起来。2D骨骼动画框架 2d骨骼适合做战斗模型演出。Unity 2D Animation2D AnimationSpineSpineDragonbonesDragonBonesLive2D live2d适合做立绘表演，仿3D。Live2D Cubism - 2D Model Maker" }, { "title": "3d模型规范和设置", "url": "/posts/3D%E6%A8%A1%E5%9E%8B%E8%A7%84%E8%8C%83%E5%92%8C%E8%AE%BE%E7%BD%AE/", "categories": "", "tags": "", "date": "2021-01-28 00:00:00 +0800", "snippet": "UWA自动资源检测服务DCC中模型导出注意事项模型 [[DCC]] 软件中，单位统一使用米（m）。 Unity 内部使用 .fbx 文件格式作为其导入链。最佳做法尽可能使用 .fbx 文件格式。 避免模型上出现长条的三角面。 针对建筑物和园林景观相关模型，要尽量使面片平均分布，这样可以避免之后在添加光照时出现奇怪的光照效果。 导出的网格必须是多边形拓扑网格，不能是贝塞尔曲线、样条曲线、NURBS、NURMS、细分曲面等。 烘培Deformers,在导出之前，确保变形体被烘培到网格模型上，如骨骼形变烘培到蒙皮权重上 如果你需要导入blend shape normals，必须要指定光滑组 smooth groups。 DCC导出面板设置, 不建议携带场景信息导出，如不建议导出摄像机、灯光、材质等信息，因为这些的信息与Unity内默认都不同。纹理贴图 贴图使用2的幂次（POT），Unity在处理2的次方尺寸的纹理时更高效，不需要再做额外的缩放操作。FBX ImporterModel 模型 不必要不要开启网格读写。 如果不需要，禁用法线或切线。Scale Factor 尽量不要在场景中改变物体的缩放比例。从理论上来讲，导入模型时将其缩小为原来的1/100与在场景中将物体缩小为原来的1/100，看起来是一样的。但实际上，在场景中缩放物体会带来很多麻烦，如子物体也会一起被缩小，引擎无法判断模型的渲染精度，从而影响运行速度。Rig 骨骼绑定Animation Type Generic：适合没有骨骼或者不是人形的角色。 Humanoid：适合人形骨骼模型，Unity对人形骨骼有优化，功能更多，使用也更方便。T-Pose 问题 如果模型导出时不处于 T-Pose，需要在骨骼映射下方的 Pose 菜单中选取 Enforce T-pose 强制设置为T-pose。但最好还是让美术把模型修改为 T-Pose 状态。 如果动画不处于T-Pose，动画映射也需要T-pose，可以在所有帧的前面创建一个 Tpose。（需要验证）Animation 动画Root Transform Root Transform Rotation，根的旋转。 Root Transform Position (Y)，根在y轴上的位移。 Root Transform Position (XZ)，根在水平面（xz平面）上的位移。Bake Into Pose 对确定需要改变的位置或旋转，取消勾选Bake Into Pose选项。 对不改变的值需要勾选 Bake Into Pose。 以跑步动作为例，逻辑上跑步直接影响水平方向的位置，这是显然的。但对动画设计师来说，人物跑步时高低重心是有变化的，上下颠簸才自然。但这种上下的颠簸只是视觉上的，不能真的去影响物体的位置，换句话说，跑步时逻辑上只做水平运动，不会上下运动。勾选了该选项，代表这个运动只是骨骼动画运动，不属于根节点；而不勾选该选项，则代表它是真正的根节点的运动。只有根节点的运动才会变成物体实际的运动。Mask 绿色代表动画可以让这一肢体运动。 红色则代表动画不会让这一肢体运动。 如果想要对状态机某一层中的动画统一应用遮罩，见：[[Animator#设置 Layers设置]] Event 动画帧事件 由于动画帧事件的标记必须在动画的时间轴上，因此会和动画数据本身耦合在一起。纯粹从程序逻辑的角度看，多种不同系统的耦合并不是好事，但为了增强游戏表现力，这么做也有充分的理由。 动画会查找当前对应物体的所有脚本，只要有名称和类型符合的Function，都会被调用。如果一个函数都没找到，就会产生一条错误信息。 事件函数仅可以带一个参数，可以是 float, int, string, Object 其中一种类型，参数的值可以在编辑动画帧事件时指定。Materials 材质原始模型文件对性能的影响点 最小化面数，不要使用微三角形，分布尽量均匀 合理的网络拓扑和平滑组 尽量少的使用材质个数 尽可能少的使用蒙皮网格 尽可能少的骨骼数量 FK与IK节点没分离，IK节点没删除模型优化 尽可能的将网格合并到一起 尽可能使用共享材质 不要使用Mesh Collider 使用合理的 [[LOD]] 级别 - 内存换CPU和GPU Skin Weights受骨骼影响个数过多 合理压缩网格 不需要rigs和BlendShapes尽量关闭 开启Project Settings—&amp;gt;Player—&amp;gt;Optimization下的Vertex Compression与Optimize Mesh Data选项 模型的Bounds不应过大，会影响相机裁剪。" }, { "title": "3d蒙皮骨骼动画", "url": "/posts/3D%E8%92%99%E7%9A%AE%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/", "categories": "", "tags": "", "date": "2021-01-27 00:00:00 +0800", "snippet": "所有蒙皮网格的变化都是由CPU计算得到的。会使CPU负担较重，蒙皮网格十分消耗CPU。骨骼动画 骨骼点是父子关系的层级结构（Transform）。 蒙皮网格主要为渲染蒙皮网格动画服务，所以蒙皮网格除了3D模型数据外，还有骨骼数据及顶点权重数据。 如果蒙皮网格上没有存储任何骨骼数据，那么它与普通网格 MeshRender 的作用没有任何区别，渲染的都是没有动画的3D模型。 蒙皮网格动画本质是用骨骼的方式去影响网格顶点，通过在每一帧里偏移模型网格上的各个顶点，让模型变形，从而形成动画的效果的。骨骼动画的工作流程 使用Maya，3DMax等制作几何模型。 使用Maya，3DMax等在几何模型上构建骨骼点（bones），并计算出每个顶点受骨骼点影响的权重值（BoneWeight）。 动画师通过骨骼点的偏移，旋转，缩放等制作动画。 导入到Unity中作为关键帧动画（AnimationClip）。 播放动画时，AnimationClip 会在某个时间点上对需要改变的骨骼做关键帧，关键帧之间做平滑插值计算。 蒙皮网格在骨骼点关键帧基础上计算新的顶点位置。骨骼点和及其权重 骨骼点本身存储在 SkinnedMeshRenderer 中。 每个顶点受影响的骨骼点序号及其权重存储在 Mesh 中。 骨骼点可以影响周围一定范围内的顶点，单一顶点也可以受到多个骨骼的影响。除了骨骼数据，模型中的每个顶点都有对其顶点本身影响最多的4个骨骼的权重值，Unity3D对这4个骨骼的权重值进行了存储，将它们存放在 BoneWeight 类型的 Struct 结构中，每个 Mesh 类都有一个 boneWeights 数组变量，用于记录所有顶点的骨骼权重值，那些没有骨骼动画的网格，就没有这些数据。 1 Bone、2Bones、4 Bones 等参数，表达的意思分别是一个顶点能被1个骨骼影响，或者被2个骨骼影响，或者被4个骨骼影响。每个顶点最多可以被4个骨骼点影响。被影响的骨骼数越多，CPU消耗在骨骼计算蒙皮上的时间就越长，消耗量越大。武器挂点 从骨骼根节点出发，依次找到角色的躯干、胸部、右肩、右臂和右手，然后在右手下面创建空物体WeaponSlot，将空物体位置旋转归0。 之后匕首、手枪等道具模型都放在武器挂点下面（作为子物体），并根据具体模型的角度调整初始朝向。SkinnedMeshRenderer 在 SkinnedMeshRenderer.bones 中存储了所有骨骼点，骨骼点在蒙皮网格中是以 Transform 数组的形式存储的。 在 Mesh.boneWeights 中存储了每个顶点被哪些骨骼点影响。（在网格中，而不是Renderer中） - boneIndex0~3 代表被影响的骨骼点的索引值。 - weight0~3 代表被 boneIndex0~3 索引的骨骼点所影响的权重值，权重在 0~1之间，且所有权重分量和为1. SkinnedMeshRenderer 用到的着色器不能使用 GPU Instancing。" }, { "title": "Unity canvas相关组件", "url": "/posts/Unity-Canvas%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6/", "categories": "", "tags": "", "date": "2020-12-12 00:00:00 +0800", "snippet": "Canvas Canvas负责合并画布上的元素。在同一个Canvas中，将相同覆盖层级，相同材质，相同图集的元素进行合并，从而减少drawcall。（Canvas里如果两个元素重叠，就认为它们是上下层关系，将所有重叠的层计算完毕后，将第0层元素合并，再将第1, 2, 3…层的元素合并，依次类推） 隐藏Canvas时，最好是把Canvas组件禁用，这样就不会给GPU发送drawcall命令，Canvas也就不会显示。这样也不会丢失它的网格缓存（Vertex Buffer）不会导致网格重新构建，实际上，disable掉Canvas组件不会触发昂贵的 OnDisable/OnEnable 回调，它只是简单的开始重新渲染已经构建好的网格。只是要注意，记得 disable 掉每帧都会执行的代码。Canvas - Render Mode Screen Space - Camera 最常用的渲染模式。 对Z轴不为0的元素，会单独提取出来渲染，不参与网格合并，使用时要注意，可能会成为一个性能点。 优先级由由高到低：SortingLayer » Order in Layer » UI 层级 Screen Space - Overlay 这种模式下空间上的前后位置不再对元素起作用。 常用在纯UI系统的区域内，这种模式下，Camera排序有别于其他模式，SortOrder参数在排 序时被重点用到，[[SortOrder]] 参数的值越大，越后渲染，越显示在前面。 World Space 适用于放在3D世界中的UI元素。 适用于制作 [[叙事UI]]， 如果是World Space的UI，则 [[RectTransform]] 的 width 和height的单位不是像素，而是米。 1Unit并不等于1米，要看 Canvas Scaler 中的设置。 Canvas Renderer Canvas下的任何可见UI对象都带有Canvas Renderer组件。 Canvas Renderer 是 Canvas 和渲染的连接组件。通过 Canvas Renderer 才能把网格绘制到 Canvas 画布上。Canvas Group 可以使用Canvas Group 组件对 [[uGUI]] 控件进行打组。 可以控制打组对象的透明度, 输入控制, Raycast等Canvas Scaler 不同分辨率屏幕适配组件，用于指定画布中元素的比例大小。 只能添加到Root-Canvas上。 常用组合 Scale With Screen Size / Expand / 100" }, { "title": "定点数", "url": "/posts/%E5%AE%9A%E7%82%B9%E6%95%B0/", "categories": "", "tags": "", "date": "2020-12-03 00:00:00 +0800", "snippet": "定点数 把整数和小数拆开来存储，用两个int整数分别表示整数部分和小数部分，或者用long长整型存储（前32位存储整数，后32位存储浮点数），long型存储会更好，它便于存储和计算。 这样，无论是整数部分还是小数部分，都用整数表示，并封装在类中。因此我们需要重载（override）所有的基本计算和比较符号，包括+、-、*、/、==、!=、&amp;gt;、&amp;lt;、&amp;gt;=、&amp;lt;=，这些符号都需要重载，重载范围包括float（浮点数）、double（双精度）、int（整数）、long（长整数）等。 除了以上这些，为了能更好地融合定点数与外部数据的逻辑计算，还需要为此编写额外的定点库，包括定点数坐标类、定点数Quaternion类等来扩展定点数。定点数的应用 网络同步中的帧同步方案。" }, { "title": "Dotween", "url": "/posts/Dotween/", "categories": "", "tags": "", "date": "2020-11-23 00:00:00 +0800", "snippet": "官方文档缓动函数图例Dotween的大多数Tween函数以拓展方法的形式提供。Basic Settings// 使用TweenParamsTweenParams para = new TweenParams();para.SetLoops(-1, LoopType.Yoyo);transform.DOMove(Vector3.one, 2).SetAs(para);transform.DOMove(position, duration) // 动画：目标值/偏移值 + 时长/速度// 基本配置 .SetSpeedBased() // 动画基于速度而不是时长 .From() // 目标位置设为初始位置 .SetRelative() // 增量运动, true=偏移量, falese=目标值 .SetDelay(1) // 设置延时 .SetId(&quot;Id&quot;) // 设置动画ID .SetLoops(-1, LoopType.Yoyo) // 设置循环次数和类型(重新开始，Yoyo，累加) .SetUpdate(UpdateType.Normal, true) // 设置动画的帧函数, 第二个参数 TRUE = ignoreTimeScale .SetRecyclable(true) // 设置是否可回收 // 为true的话，动画播放完会被回收，缓存下来，不然播完就直接销毁 .SetAutoKill(false) // 非无限循环的动画是否自动destroy； // 若非无限循环的动画为false，停止后可以Restart(),否则不可以 .Pause() // 创建时处于暂停状态// Ease曲线 .SetEase(Ease.Linear) // 默认Ease曲线 .SetEase(AnimationCurve) // 使用AnimationCurve当作参数 .SetEase(MyEaseFun) // 自定义, 以回调函数为参数 // 回调函数 .OnComplete(() =&amp;gt; { }) // 动画完成回调 .OnStepComplete( () =&amp;gt; {}) // 完成单个循环周期时触发 .OnKill(() =&amp;gt; { }) // 动画销毁时回调 .OnStart(() =&amp;gt; { }) // 只在第一次播放动画时调用，在play之前调用 .OnPlay(() =&amp;gt; { }) // 动画播放时回调,暂停后重新播放也会调用 .OnPause(() =&amp;gt; { }) // 动画暂停时回调 .OnRewind(() =&amp;gt; { }) // 动画回退时回调, 以下情况会被调用 // 使用DORestart重新播放时 // 使用Rewind倒播动画完成时 // 使用DOFlip翻转动画完成时 // 使用DOPlayBackwards反向播放动画完成时 .OnUpdate(() =&amp;gt; { }) // 帧回调 .OnWaypointChange((value) =&amp;gt; { }) // 在路径动画时，改变目标点时的回调，参数为当前目标点的下标);//返回值是运动距离的百分比 值应为0~1之间，最后的值需为1,不然停留的位置不会是目标位置private float MyEaseFun(float time, float duration, float overshootOrAmplitude, float period){ return time / duration;}// // Demousing DG.Tweening; //引入命名空间public class DOTWeenTest : MonoBehaviour{ Tweener twe; //声明一个Tweener对象 void Start() { twe = transform.DOMove(new Vector3(3, 4, 0), 2);//将动画保存在Tweener对象中 twe.Pause();//暂停,防止自动播放 twe.SetAutoKill(false);//关闭动画自动销毁 } //创建两个方法事件,控制前放后倒放 public void Forward() { twe.PlayForward(); //该动画正放 } public void Back() { twe.PlayBackwards(); //该动画倒放 }}Controlling// 一共有三种方式控制tween动画, 所有三种方式共享相同的方法名，只是扩展方法形式增加了 DO 前缀// 1. 通过DOTween类的静态函数控制DOTween.PauseAll(); // All versionDOTween.Pause(&quot;badoom&quot;); // Id versionDOTween.Pause(transform); // target version// 2. 直接通过tween动画控制myTween.Pause();// 3. 扩展方法形式transform.DOPause();// 如果想在动画结束之后使用这些方法，一定要disable掉 AutoKilltransform.DOPlay(); // 播放，播放的动画不能是正在播放的，也不能是播放完成的transform.DOPause(); // 暂停此组件上的所有动画transform.DORestart(); // 重播transform.DORewind(); // 倒播，此方法会直接退回起始点transform.DOSmoothRewind(); // 平滑倒播，此方法会按照之前的运动方式从当前位置退回起始点 transform.DOKill(); // 销魂此组件上的所有动画transform.DOFlip(); // 翻转补间的方向transform.DOGoto(1.5f, true); // 跳转, (跳转的时间点，跳转后是否播放动画)transform.DOPlayBackwards(); // 反向播放动画 // 在动画播放到一半时执行，会退回起始点，在一开始执行看不到效果是因为，物体本身就在起始点transform.DOPlayForward(); // 正向播放动画transfomr.TogglePause(); // 当暂停时，执行就继续播放，播放时，执行就暂停Get Tween Data// DOTween类的静态方法DOTween.PausedTweens(); // 返回所有暂停的动画，没有则返回nullDOTween.PlayingTweens(); // 返回所有真正播放的动画，没有则返回nullDOTween.TweensById(&quot;id&quot;, true); // 返回对应ID的动画数组，第二个参数表示是否只收集正在播放的动画DOTween.TweensByTarget(transform, true); // 返回给定对象的数组DOTween.IsTweening(transform); // 收集传入的对象是否有动画在活动DOTween.TotalPlayingTweens(); // 正在播放的动画的总数，目前处于延迟播放状态的动画也算// 动画实例的方法tweener = transform.DOMove(Vector3.one, 2);tweener.fullPosition = 1; // 表示动画执行位置的属性，可读可写tweener.CompletedLoops(); // 表示动画执行完的次数tweener.Delay(); // 获取动画的延迟时间tweener.Duration(false); // 获取动画的持续时间, 参数为true 表示计算循环的时间，无限循环为Infinitytweener.Elapsed(); // 动画已播放的时间, 参数为true 表示计算循环的时间tweener.ElapsedDirectionalPercentage(); // 返回动画进度的百分比, [0~1]tweener.ElapsedPercentage(true); // 返回动画区间已用的百分比, true=返回值是循环总区间的已用百分比tweener.IsActive(); // 动画是否在活动tweener.IsBackwards(); // 是否是反向动画tweener.IsComplete(); // 动画是否完成tweener.IsInitialized(); // 是否已经初始化tweener.IsPlaying(); // 是否正在播放tweener.Loops(); // 返回循环次数，无限循环为InfinityWaitFor Coroutines / Tasksprivate IEnumerator PlayAnimation(){ tweener = transform.DOMove(Vector3.one, 2); yield return tweener.WaitForCompletion(); // 等待动画执行完 yield return tweener.WaitForElapsedLoops(2); // 等待指定的循环次数 yield return tweener.WaitForKill(); // 等待动画被杀死 yield return tweener.WaitForPosition(0.5f); // 等待动画执行指定时间 // 等待动画回退, 以下情况会继续执行函数 // 使用DORestart重新播放时 // 使用Rewind倒播动画完成时 // 使用DOFlip翻转动画完成时 // 使用DOPlayBackwards反向播放动画完成时 yield return tweener.WaitForRewind(); yield return tweener.WaitForStart(); // 等待Start执行后继续执行}private async Task PlayAnimation(){ myTween = transform.DOMove(Vector3.one, 2); await myTween.AsyncWaitForCompletion(); await myTween.AsyncWaitForElapsedLoops(); await myTween.AsyncWaitForKill(); await myTween.AsyncWaitForPosition(0.3f); await myTween.AsyncWaitForRewind(); await myTween.AsyncWaitForStart();}Tweener - Any Valueint timer = 0;DOTween.To( () =&amp;gt; timer, x =&amp;gt; timer = x, 0.2f, animDuration);Tweener - Transformtransform.DOMove(); // 世界坐标移动transform.DOLocalMove(); // 局部坐标移动transform.DORotate(new Vector3(0, 90, 0), 2); // 旋转到给定的值，改变的是欧拉角transform.DORotateQuaternion(new Quaternion(0.1f, 0.1f, 0.1f, 0.1f), 2); // 旋转到给定的值，改变四元数transform.DOLocalRotate(new Vector3(0, 90, 0), 2);transform.DOLocalRotateQuaternion(new Quaternion(0.1f, 0.1f, 0.1f, 0.1f), 2);transform.DOLookAt(new Vector3(0, 0, 0), 2); // 平滑的让自身的z轴正方向指向目标点transform.DOScale(new Vector3(2, 2, 2), 2);transform.DOScaleX(3, 2);// 冲击transform.DOPunchPosition(new Vector3(0, 1, 0), duration, vibrato, elascity);transform.DOPunchRotation(new Vector3(0, 90, 0), 2, 2, 0.1f);transform.DOPunchScale(new Vector3(2, 2, 2), 2, 2, 0.1f);// 震动transform.DOShakePosition(1, 5, 10, 50, true);transform.DOShakeRotation(3);transform.DOShakeScale(3);// 混合动画// 原本同时执行两个Move方法，只会执行最新的一个动画命令// 假设起始点为(0,0,0)，结果是物体运动到了（2,2,2）transform.DOMove(new Vector3(1, 1, 1), 2);transform.DOMove(new Vector3(2, 2, 2), 2);// DOBlendableMoveBy允许多个同时执行, 且它是增量动画，参数不是目标点，而是要移动的量// 假设起始点为(1,1,1)，最后动画停止时的坐标是(1,2,2)transform.DOBlendableMoveBy(new Vector3(1, 1, 1), 1);transform.DOBlendableMoveBy(new Vector3(-1, 0, 0), 1); Tweener - uGUI// RectTransformtrans.DOAnchorPos() // Imageimage.DOFade(endValue, duration).SetAutoKill(false).Pause(); // 渐变image.DOColor(endValue, duration).SetEase(Ease.Linear).Pause(); // 颜色image.DOFillAmount(endValue, duration).SetEase(Ease.Linear).SetLoops(-1, LoopType.Yoyo) //填充 .OnStepComplete( () =&amp;gt; { image.fillClockwise = !image.fillClockwise; }).Pause();// Text 通过动画把现有text变成value值。（Replace, Add, Scramble）text.DOText(&quot;This text will replace the existing one&quot;, duration).Pause(); // 替换text.DOText(&quot;This text will be added to the existing one&quot;, duration).Pause(); // 追加text.DOText(&quot;This text will appear from scrambled chars&quot;, duration, true, ScrambleMode.All); // 乱码// Sliderslider.DOValue(1, duration); // 滑动条的值Tweener - MaterialsMaterial material;material.DOColor(toColor, duration); // 材质颜色material.DOColor(Color.clear, &quot;_Color&quot;, 2); // 按照shader的属性名，修改颜色material.DOColor(toColor, &quot;_EmissionColor&quot;, duration); // 发光material.DOFade(0, 2); // 修改alpha值material.DOGradientColor(Gradient, &quot;_Color&quot;, 3); // 颜色渐变material.DOOffset(new Vector2(1, 1), 2); // 改变材质offset的值material.DOVector(new Vector4(0, 0, 0, 1), &quot;_Color&quot;, 3); // 改变shader属性的名称对应的Vector4值material.DOBlendableColor(Color.red, &quot;_Color&quot;, 3); // 颜色混合Tweener - Cameracamera.DOAspect(0.6f, 2); // 屏幕视角的宽高比camera.DOColor(Color.blue, 2); // 改变相机background参数的颜色camera.DONearClipPlane(200, 2); // 改变相机近切面的值camera.DOFarClipPlane(2000, 2); // 改变相机远切面的值camera.DOFieldOfView(30, 2); // 改变相机FOV的值camera.DOOrthoSize(endValue, duration); // 改变相机正交大小camera.DOPixelRect(new Rect(0f, 0f, 600f, 500f), 2); // 按照屏幕像素计算的显示范围camera.DORect(new Rect(0.5f, 0.5f, 0.5f, 0.5f), 2); // 按照屏幕百分比计算的显示范围camera.DOShakePosition(1, 10, 10, 50, false); // 相机震动SequenceDOTween.Sequence() // 返回一个新的Sequence .Append(nestedTween) // 添加动画到队列中 .AppendInterval(1) // 添加时间间隔 .Insert(2, nestedTween) // 按时间点插入动画, 第一个参数为时间 .Join(nestedTween) // 加入的动画和当前正在执行的动画一起执行 .PrependCallback( () =&amp;gt; {} ) // 前置回调， 在Sequence的最开始添加回调 .InsertCallback(3.0f, InsertCallBack) // 按时间点插入回调函数 .AppendCallback(CallBack); // 添加回调到动画中Sequence s = DOTween.Sequence();// 添加动画到队列中s.Append(cube.DOMoveX(6, duration).SetRelative().SetEase(Ease.InOutQuad));// 按时间点插入动画s.Insert(0, cube.DORotate(new Vector3(0, 45, 0), duration / 2).SetEase(Ease.InQuad).SetLoops(2, LoopType.Yoyo));s.Insert(duration / 2, cube.GetComponent&amp;lt;Renderer&amp;gt;().material.DOColor(Color.yellow, duration / 2));// Set the whole Sequence to loop infinitely forward and backwardss.SetLoops(-1, LoopType.Yoyo);Pathspublic Transform target;public PathType pathType = PathType.CatmullRom;public Vector3[] waypoints = new[] { new Vector3(4, 2, 6), new Vector3(8, 6, 14), new Vector3(4, 6, 14), new Vector3(0, 6, 6), new Vector3(-3, 0, 0)};void Start(){ // Create a path tween using the given pathType, Linear or CatmullRom (curved). // Use SetOptions to close the path // and SetLookAt to make the target orient to the path itself Tween t = target.DOPath(waypoints, 4, pathType) .SetOptions(true) .SetLookAt(0.001f); // Then set the ease to Linear and use infinite loops t.SetEase(Ease.Linear).SetLoops(-1);}// DoTween Path ComponentFollowpublic Transform target; // Target to followVector3 targetLastPos;Tweener tween;void Start(){ // First create the &quot;move to target&quot; tween and store it as a Tweener. // In this case I&#39;m also setting autoKill to FALSE so the tween can go on forever // (otherwise it will stop executing if it reaches the target) tween = transform.DOMove(target.position, 2).SetAutoKill(false); // Store the target&#39;s last position, so it can be used to know if it changes // (to prevent changing the tween if nothing actually changes) targetLastPos = target.position;}void Update(){ // Use an Update routine to change the tween&#39;s endValue each frame // so that it updates to the target&#39;s position if that changed if (targetLastPos == target.position) return; // Add a Restart in the end, so that if the tween was completed it will play again tween.ChangeEndValue(target.position, true).Restart(); targetLastPos = target.position;}Dotween Animation Component 制作与设计 不想直接播放，就不要选中 AutoPlay 如果非无限循环的动画如果以后想要重复播放，就不要选中 AutoKil 代码控制 // 根据ID控制动画 // 播放 DOTween.Restart(&quot;id&quot;); // 停止 DOTween.Complete(&quot;id&quot;); // 控制单个 DOTweenAnimation 组件 [SerializeField] private DOTweenAnimation bg; bg.DORestart(); bg.DOPlayNext(); // 播放下一个Tween Animation bg.DOPlayById(id); // 播放指定ID的动画 bg.DOPlayAllById(id); bg.DORestartById(); bg.DORestartAllByID(); 常见问题 想要复用动画，不能调用Play()，需要调用Restart()方法 调用play方法，这个动画 不能是正在播放的，也不能是播放完成的， Restart方法成功调用必须保证 AutoKill = false 原本同时执行两个Move方法，只会执行最新的一个动画命令 DOBlendableMoveBy允许多个同时执行, 且它是增量动画，参数不是目标点，而是要移动的量 " }, { "title": "Csharp Linq", "url": "/posts/CSharp-LINQ/", "categories": "", "tags": "", "date": "2020-10-25 00:00:00 +0800", "snippet": "LINQ Language Integrated Query 语言集成查询。 System.Linq 命名空间为 IEnumerable&amp;lt;T&amp;gt; 接口提供了50多个扩展方法，以实现标准查询操作。using System.Linq;标准查询操作符 大多数标准查询操作符不一定在赋值的时候即求值，确切的说，操作符中只是描述了返回的集合中应该有什么，而没有描述具体应该如何遍历数据项并生成新集合。 只有在需要遍历集合中的项时，才会真正对表达式进行求值。 查询操作符的谓词应该只对条件求值，不应该有任何副作用（比如打印到控制台）。查询表达式 用着的时候再看 DemoIEnumerable&amp;lt;string&amp;gt; selection = from word in words where word.Contains(&#39;*&#39;) select word; 过滤(筛选)操作符Where System.Linq.Enumerable.Where() 从集合中筛选出符合[[CS-Delegate#Predicate 谓词]]要求的元素。 Where方法的结果是一个对象，它封装了根据一个给定谓词对一个给定序列进行筛选的操作。 由于 IEnumerable&amp;lt;T&amp;gt;.Where() 输出的是一个新的 IEnumerable&amp;lt;T&amp;gt; 集合。 Where主要用于减少集合项的数量。 可综合运用 Where 和 Select 来获得原始集合的子集。string[] words = {&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;};// 注意和Select区分words.Where(word =&amp;gt; word.Length &amp;gt; 3);// 结果： &quot;zero&quot;, &quot;three&quot;, &quot;four&quot;words.Where((word, index) =&amp;gt; index &amp;lt; word.Length);// 结果： &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;投影(投射)操作符Select 依照给定的规则，由序列中的每一项生成另一个元素。即：返回从源元素到结果元素的一对一投影。 Select可以对数据进行完全的转换。string[] words = {&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;};words.Select(word =&amp;gt; word.Length);// 4，3，3，5，4words.Select((word, index) =&amp;gt; index.ToString() + &quot;: &quot; + word); // &quot;0: zero&quot;......聚合操作符SumCount 使用 Count() 对元素计数。 有Count属性的集合应首选属性，而不要用LINQ的Count()方法，可能会遍历整个集合。AverageMinMaxAggregatestring[] words = {&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;};int[] numbers = {0, 1, 2, 3, 4};numbers.Sum(); // 求和 10numbers.Count(); // 计数 5numbers.Count(n =&amp;gt; n &amp;gt; 2); // 符合要求的为3,4 一共2个，结果为2numbers.Average(); // 求平均 2words.Min(word =&amp;gt; word.Length); // 求符合selector的最小的项 3words.Max(word =&amp;gt; word.Length); // 求符合selector的最大的项numbers.Aggregate(&quot;seed&quot;, (current, item) =&amp;gt; current + item, result =&amp;gt; result.ToUpper()); // 结果 &quot;SEED01234&quot; 连接操作符Concatstring[] words = {&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;};int[] numbers = {0, 1, 2, 3, 4};// 连接操作符 ---------------------------------------------------numbers.Concat(new[] {2,3,4,5,6}); // 连接 0,1,2,3,4,2,3,4,5,6 转换操作符ToArrayToListToDictionaryToLookupstring[] words = {&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;};int[] numbers = {0, 1, 2, 3, 4};// 转换操作符 ---------------------------------------------------numbers.ToArray(); // 转换为 int[]numbers.ToList(); // 转换为 List&amp;lt;int&amp;gt;words.ToDictionary(w =&amp;gt; w.Substring(0,2)); // 每个键只能出现一次，否则会抛出异常words.ToLookup(word =&amp;gt; word[0]);元素操作符ElementAtFirstLastSingle // 元素操作符 -------------------------------------------------- string[] words = {&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;}; int[] numbers = {0, 1, 2, 3, 4}; words.ElementAt(2); // &quot;one&quot; words.ElementAtOrDefault(10); // null words.First(); // &quot;zero&quot; words.First(w =&amp;gt; w.Length == 3); // &quot;one&quot; words.First(w =&amp;gt; w.Length == 10); // 异常 words.FirstOrDefault(w =&amp;gt; w.Length == 10); // null words.Last(); // &quot;four&quot; words.Single(); // 异常，不止一个 words.SingleOrDefault(); // 异常，不止一个 words.Single(word =&amp;gt; word.Length == 5); // &quot;three&quot; words.Single(word =&amp;gt; word.Length == 10); // 异常 words.SingleOrDefault(w =&amp;gt; w.Length == 10); // null 相等操作符SequenceEqual // 相等操作符 -------------------------------------------------- words.SequenceEqual(new []{&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;}); words.SequenceEqual(new[] {&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;}, StringComparer.OrdinalIgnoreCase);生成操作符DefaultIfEmptyRangeRepeat // 生成操作符 -------------------------------------------------- numbers.DefaultIfEmpty(); // 序列不为空，返回原始序列，否则返回含有单个元素的序列，其中的元素是相应类型的默认值 Enumerable.Range(15, 2); // 15，16 Enumerable.Repeat(26, 2); // 26，26 分组操作符ToLoopupGroupByTakeSkipTakeWhileSkipWhile // 分组操作符 -------------------------------------------------- string[] words = {&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;}; int[] numbers = {0, 1, 2, 3, 4}; words.ToLookup(word =&amp;gt; word[0]); words.GroupBy(word =&amp;gt; word.Length); // 括号内为分组的键 words.GroupBy(word =&amp;gt; word.Length, word =&amp;gt; word.ToUpper()); words.Take(2); // 取前2个 words.Skip(2); // 跳过前2个 words.TakeWhile(word =&amp;gt; word.Length &amp;lt;= 4); // 取，直到不满足谓词要求 &quot;zero&quot;, &quot;one&quot;, &quot;two&quot; words.SkipWhile(word =&amp;gt; word.Length &amp;lt;= 4); // 跳过，直到不满足谓词要求 &quot;three&quot;, &quot;four&quot;检查操作符AllAnyContains // 检查操作符 -------------------------------------------------- words.All(word =&amp;gt; word.Length &amp;gt; 3); // 是否任意一个都满足 false words.Any(); // 存在元素 true words.Any(word =&amp;gt; word.Length == 6); // 是否存在一个满足 false words.Contains(&quot;FOUR&quot;); // 是否包含 false words.Contains(&quot;FOUR&quot;, StringComparer.OrdinalIgnoreCase); // 是否包含 true 集合操作符DistinctIntersectUnionExcept // 集合操作符 -------------------------------------------------- string[] abbc = {&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;}; string[] cd = {&quot;c&quot;, &quot;d&quot;}; abbc.Distinct(); // 去重 &quot;a&quot;, &quot;b&quot;, &quot;c&quot; abbc.Intersect(cd); // 交集 &quot;c&quot; abbc.Union(cd); // 并集 &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; abbc.Except(cd); // 差集 &quot;a&quot;, &quot;b&quot; cd.Except(abbc); // 差集 &quot;d&quot; 排序操作符OrderByReverse words.OrderBy(w =&amp;gt; w); words.OrderBy(w =&amp;gt; w[1]); words.OrderByDescending(w =&amp;gt; w.Length); words.OrderBy(w =&amp;gt; w.Length).ThenBy(w =&amp;gt; w); words.OrderBy(w =&amp;gt; w.Length).ThenByDescending(w =&amp;gt; w); words.Reverse();" }, { "title": "Csharp Task", "url": "/posts/CSharp-Task/", "categories": "", "tags": "", "date": "2020-09-20 00:00:00 +0800", "snippet": "Task 任务是可能出现高延迟的工作单元，作用是产生结果值或者希望的副作用。 任务代表一个异步工作，而线程是做这件工作的工作者。 任务和委托类似，区别是委托同步执行，任务把委托从同步执行转变为异步执行，即从线程池中取一个工作者线程[[异步]]执行任务。 启动一个任务，控制几乎立刻返回给调用者，无论这个任务要执行多少工作。 Task类：System.Threading.Tasks。 任务并行库 TPL - Task Parallel Library。 Task承诺(Promise)在未来(Future)的某个时刻，其内部会含有值或错误。基于任务的异步模式 TAP - Task-based Asynchronous Pattern。 TAP使用 async/await 让编译器来承担异步程序的复杂性，从而使程序员可以集中精力实现真正的业务逻辑。async 使用 async 修饰符声明的方法，其中可包含异步方法调用，并使用 await 表达式等待异步方法结束。 具有 async 修饰的方法也会运行于调用者线程中，如果其中没有用 await 等待任何“可等待”的任务，则它会像普通方法一样在调用者线程中同步执行；仅仅使用 async 关键字并不会改变执行线程。 从调用者的角度看，调用具有 async 关键字的方法与调用普通方法并无差别，它仅仅只是一个能返回异步类型的方法。await await 阻塞的是当前执行的方法，而非当前线程。在异步方法中遇到 await 关键字时，当前的执行路径会分成两条：一条为当前线程，它会立即返回到调用者继续执行后续的代码；一条为自动分配的子线程，这个子线程会等待 await 右边的异步任务完成，之后继续执行异步方法中的后续代码。 await 操作符会自动将逻辑上的返回值从 Task 对象中提取出来。private static void PrintPageLength(){ Task&amp;lt;int&amp;gt; lengthTask = GetPageLengthAsync(&quot;http://google.com&quot;); Debug.Log(lengthTask.Result.ToString());}private static async Task&amp;lt;int&amp;gt; GetPageLengthAsync(string url){ using (HttpClient client = new HttpClient()) { Task&amp;lt;string&amp;gt; fetchTextTask = client.GetStringAsync(url); int length = (await fetchTextTask).Length; return length; }}Task API检查状态// 检查任务的状态task.IsCompletedtask.Status读取返回值// 读取返回值，此操作会自动造成当前线程阻塞task.Result有效异步返回值类型 对于一个异步方法，只有在作为事件订阅者时才应该返回void，在其他不需要特定返回值的情况下，最好将方法声明为返回Task，这样调用者可以等待操作完成，以及探测失败情况。 相比异步任务，创建 Task 对象的开销基本可以忽略，所以不要返回 null，不然调用者还需要检查是否为 null。 await 支持的返回类型为可等待类型，即任何包含 GetAwaiter() 方法的类型。Task 如果一个异步方法没有返回值，就使用 Task。 如果异步方法中的操作一定异步完成，或者可能缓存常见的结果Task对象，首选 Task&amp;lt;TResult&amp;gt;// 不返回对象，但可以通过Task检查任务状态Task// 返回可供调用者使用的对象Task&amp;lt;TResult&amp;gt;ValueTask 当异步方法无需执行异步任务而提前返回时，该类型可以提供轻量级的对象构造。 如果操作可能同步完成并且不能有效的缓存所有常见的返回值，则ValueTask&amp;lt;T&amp;gt; 更合适。using System.IO.Compression;private static async ValueTask&amp;lt;byte[]&amp;gt; CompressAsync(byte[] buffer){ if (buffer.Length == 0) { return buffer; } using MemoryStream memoryStream = new MemoryStream(); using GZipStream gZipStream = new GZipStream(memoryStream, CompressionMode.Compress);) await gZipStream.WriteAsync(buffer, 0, buffer.Length); return memoryStream.ToArray();}IAsyncEnumerableIAsyncEnumerable&amp;lt;T&amp;gt;IAsyncEnumeratorIAsyncEnumerator&amp;lt;T&amp;gt;任务取消 任务会定期轮询 CancellationToken 令牌对象，检查是否发出了取消请求。 CancellationToken 是 struct，可以拷贝值。CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();Task task = Task.Run( () =&amp;gt; Func(), cancellationTokenSource.Token);// 取消任务cancellationTokenSource.Cancel();" }, { "title": "Csharpio流架构", "url": "/posts/CSharpIO%E6%B5%81%E6%9E%B6%E6%9E%84/", "categories": "", "tags": "", "date": "2020-08-25 00:00:00 +0800", "snippet": "" }, { "title": "Csharp迭代器", "url": "/posts/CSharp%E8%BF%AD%E4%BB%A3%E5%99%A8/", "categories": "", "tags": "", "date": "2020-08-23 00:00:00 +0800", "snippet": "迭代器相关接口IEnumerator 枚举数 IEnumerator 中包含了遍历集合必需的方法，允许使用迭代器模式而不是索引模式遍历元素集合。 枚举数相当于一个“游标”，记录了当前的遍历状态，每个游标独立于其它的游标。 通过枚举数确定第一个和下一个元素，就不需要事先知道元素总数，也不需要按照索引获取元素。MoveNext 从集合的一个元素移动到下一个元素，同时返回是否已经遍历完集合中的每个元素。Current 只读属性，返回当前的元素。IEnumerable 可枚举 所有的集合至少要实现 IEnumerable&amp;lt;T&amp;gt;（可枚举的） 接口。 IEnumerable 唯一的作用就是通过 GetEnumerator 返回一个 IEnumerator 枚举数实例。IEnumerator 通常由一个嵌套类实现，以便访问到集合的内部变量；并维护每个独立游标的状态，以便支持同时维护多个游标的情况。foreach “运行时”并不认识 foreach，C#编译器会对代码进行必要的转换。 对于数组：依靠 Length 属性和数组索引操作符 []，把foreach转化为等价的 for 循环。 对于集合：通过迭代器遍历整个集合。（不需要长度已知，也不需要可以按索引检索） foreach 循环变量是只读变量，循环期间禁止修改。 如果 IEnumerator 实现了 IDisposable 接口，退出 foreach 循环后会调用 Dispose() 方法清理状态。标准查询[[LINQ]]foreach 循环中不能修改集合 foreach变量并不是原本的集合元素，对 foreach 变量赋值并不能改变集合元素本身，会引起混淆。 foreach循环期间也不能改变集合中元素的数量。如果修改元素个数，iterator中应该忽略还是集成新的修改？ 综上，C#编译器禁用了foreach中修改集合。Duck Typing C#编译器不要求一定要实现 IEnumerable/IEnumerable&amp;lt;T&amp;gt; 才能对一个数据类型进行遍历。只需要能够查找到能返回“包含Current属性和MoveNext()方法的一个类型”的GetEnumerator()方法。Duck typing按名称查找方法，而不依赖接口或显式方法调用。当 [[DuckTyping]] 找不到可枚举模式的恰当实现时，编译器才会检查集合是否实现了接口。枚举数模式 为自定义类型实现迭代的功能, 实现 IEnumerable 接口。 如果某个类型实现了IEnumerable接口，就意味着它可以被迭代访问。 把被迭代对象和迭代器分开，使得多个迭代器可以同时独立地操作同一个序列。// IEnumerable相当于数据库中的表public class CountingEnumerable : IEnumerable&amp;lt;int&amp;gt; { // 因为C#不能以返回类型区分两个重载方法 // 隐式实现 IEnumerator public IEnumerator&amp;lt;int&amp;gt; GetEnumerator() { return new CountingEnumerator(); } // 使用显示接口实现 IEnumerable IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } // IEnumerator 嵌套类相当于数据库中的游标 private class CountingEnumerator : IEnumerator&amp;lt;int&amp;gt; { private int current = -1; public bool MoveNext() { current++; return current &amp;lt; 10; } public void Reset() { current = -1; } public int Current =&amp;gt; current; object IEnumerator.Current =&amp;gt; Current; public void Dispose() { } }}迭代器块 迭代器模式简化了枚举数模式的语法，C#编辑器会自动把其扩展成枚举数模式的代码。 使用 yield return 语句实现迭代器块方法。 当编译器看到迭代器块时，会为类创建一个嵌套类型作为它的游标，来正确记录块中的位置和局部变量的值。 迭代器块实际上可以让你在这个代码块所涉及的特定位置“暂停”当前执行流，并随后携带着同样的状态返回同一位置。public IEnumerator GetEnumerator(){ for (int i = 0; i &amp;lt; values.Length; ++i) { yield return value[i]; }}" }, { "title": "Csharp枚举类型", "url": "/posts/CSharp%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/", "categories": "", "tags": "", "date": "2020-08-15 00:00:00 +0800", "snippet": "enum 枚举 枚举用来定义常量值的集合。 枚举是不能继承的，所有值类型都不能继承。只是复用了继承的语法指定基础类型。 枚举可以是任意整型，在enum名称后加 : 指定整型类型 整型类型的位数决定了枚举的性能，及能容纳的值个数。 声明枚举时要提供 0 值代表 Unknown 或者 None// 其他可用类型有：byte(1B)、sbyte、short、ushort、int(4B)、uint、long、ulongpublic enum Month : int {}位标志 使用 [System.Flags] 特性, 可以把枚举作为位标志处理(不一定继承byte)。 位标志用于表示复合值（标志的集合）。其名称通常为复数。 位标志的每个值都要占用二进制的一位，所以能够容纳的值比较少。32位的 int 最多可以容纳32个标志枚举值。[System.Flags]public enum WeekDays{ None = 0x00, //0000 0000 = 0 Sunday = 0x01, //0000 0001 = 1 &amp;lt;&amp;lt; 0 Monday = 0x02, //0000 0010 = 1 &amp;lt;&amp;lt; 1 Tuesday = 0x04, //0000 0100 = 1 &amp;lt;&amp;lt; 2 Wednesday = 0x08, //0000 1000 = 1 &amp;lt;&amp;lt; 3 Thursday = 0x10, //0001 0000 = 1 &amp;lt;&amp;lt; 4 Friday = 0x20, //0010 0000 = 1 &amp;lt;&amp;lt; 5 Saturday = 0x40 //0100 0000 = 1 &amp;lt;&amp;lt; 6};位标志操作// 检测特定位是否存在days.HasFlag(WeekDays.Sunday);// 去掉位标志中的一个元素days = days &amp;amp; (~WeekDays.Sunday)位域的使用场景 Unity的 Layer 定义 系统的访问权限 执行状态 文件的读写属性enum 和 string 相互转换 枚举值转换成字符串（枚举名）WeekDays.Sunday.ToString(); 字符串转换成枚举值// 转换失败返回falsebool success = System.Enum.TryParse(&quot;Monday&quot;, out WeekDays days); enum 与 int 相互转换 枚举值转换成整型(int)Color.Red;(byte)Color.Green; 整型转换成枚举值// 可以强转(Color)2;// 也可以例用Enum的静态方法 Color color = (Color)Enum.ToObject(typeof(Color), 2); 判断某个整型是否定义在枚举中System.Enum.IsDefined(typeof(Color), 2);遍历枚举值foreach (Weekdays day in Enum.GetValues(typeof(Weekdays))){ Debug.Log((int)day+ &quot;:&quot; + day);}" }, { "title": "物理关节", "url": "/posts/%E7%89%A9%E7%90%86%E5%85%B3%E8%8A%82/", "categories": "", "tags": "", "date": "2020-08-12 00:00:00 +0800", "snippet": "常用3D关节固定关节 Fixed Joint 用于固定连接两个物体，不可滑动或旋转。例如可以表现抓住物体。铰链关节 Hinge Joint 连接的两个物体可以以关节点为中心旋转。例如屋门。弹簧关节 Spring Joint 用弹簧连接两个物体，两者太近或太远都会受到弹簧的回复力。 可以用弹性(Spring)和阻尼(Damper)调节弹的弹性。人物关节 Character Joint 专门用来制作人形角色的关节连接。一般用于表现游戏中无生命的人形角色随外力运动的效果。由于配置复杂，需要使用Ragdoll工具辅助制作。常用2D关节2D固定关节 Fixed Joint 2D2D铰链关节 Hinge Joint 2D2D滑动关节 Slider Joint 2D 用于两个能够沿一个方向互相滑动、但不可分开的物体。例如抽屈和桌子的连接即为滑动关节。2D车轮关节 Wheel Joint 2D 专门用来制作2D游戏中的车辆(侧视角)。由于提供了马达车辆悬挂，很容易做出2D游戏中的简易小车。" }, { "title": "射线检测", "url": "/posts/%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B/", "categories": "", "tags": "", "date": "2020-08-07 00:00:00 +0800", "snippet": "射线检测 在游戏中发射一条虚拟射线 Ray，并观察该射线是否击中了某个物体，以及具体击中了该物体的哪个位置。 射线不只有简单的直线射线，还有球形射线，盒子射线，胶囊体射线等。Raycast检测条件 被检测的对象一定要有 [[碰撞体]] 组件射线检测的应用场景 判断角色是否落地。 判断子弹是否击中目标。创建和发射射线创建从原点向上的射线Ray ray = new Ray(Vector3.zero, Vector3.up);创建从摄像机到鼠标所指位置的射线// 获得当前鼠标指针在屏幕上的位置（单位是像素）Vector2 mousePos = Input.mousePosition;// 创建一条射线，起点是摄像机位置，方向指向鼠标指针所在的点//（隐含了从屏幕到世界的坐标转换）Ray ray2 = Camera.main.ScreenPointToRay(mousePos);创建从屏幕中心到场景的射线Camera camera = Camera.main;Vector3 point = new Vector3(camera.pixelWidth / 2, camera.pixelHeight / 2, 0);Ray ray3 = camera.ScreenPointToRay(point);发射射线// 将ray发射出去，例如：if (Physics.Raycast(ray, out RaycastHit hitInfo, 10000, LayerMask.GetMask(&quot;Enemy&quot;))){ if (hitInfo.collider.gameObject.CompareTag(&quot;Boss&quot;)) { { // todo something }}// 球形射线Physics.SphereCast// 盒子射线Physics.BoxCast// 胶囊体射线Physics.CapsuleCast// 如果需要射线穿过物体，得到沿途所有的碰撞信息Physics.RaycastAll检测范围内碰撞体 Overlap 可以用于检测炸弹爆炸半径内受到波及的物体等。// 检测球形范围内的怪物var colliders = Physics.OverlapSphere(transform.position, radius);foreach (var target in colliders){ if (target.CompareTag(&quot;Monster&quot;)) { return true; }}// 检测盒子范围内Physics.OverlapBox// 检测胶囊体范围内Physics.OverlapCapsule射线调试Debug.DrawLine(ray.origin, ray.direction * 10, Color.red);Debug.DrawRay(ray.origin, ray.direction * 10, Color.yellow);解决某些对象遮挡射线的问题 把想要忽略射线的对象放到 Ignore Raycast 层。 射线是通过collider判断的，只需要把collider移除就不会响应射线" }, { "title": "软体", "url": "/posts/%E8%BD%AF%E4%BD%93/", "categories": "", "tags": "", "date": "2020-08-05 00:00:00 +0800", "snippet": "软体 软体的外形会随着力和加速度的变化而变化，能够逼真还原碰撞发生的具体过程。软体的使用场景 模拟皮球的反弹。 模拟车辆的碰撞损坏。 模拟水体的运动。 模拟柔软物体。" }, { "title": "碰撞体", "url": "/posts/%E7%A2%B0%E6%92%9E%E4%BD%93/", "categories": "", "tags": "", "date": "2020-08-05 00:00:00 +0800", "snippet": "碰撞器物体发生碰撞的两个必要条件 两个物体都要挂载 Collider 组件 其中一个物体是刚体，挂载 Rigidbody 组件基本碰撞体 Box Collider (2D) Sphere Collider Capsule Collider Circle Collider 2D组合碰撞体 子物体所挂载的碰撞体组件，也会成为父物体物理外形的一部分。 既可以给一个物体添加多个基本碰撞体，也可以把碰撞体组件挂载到子物体上，这样都能构造出组合碰撞体。 组合碰撞体适合于汽车，枪支等不规则的游戏物体。碰撞事件// 参数为碰撞信息，碰撞事件的参数信息要比触发事件的多一些private void OnCollisionEnter(Collision collisionInfo) {}private void OnCollisionStay(Collision collisionInfo) {}private void OnCollisionExit(Collision collisionInfo) {}碰撞体分类静态碰撞体 静态碰撞体指没有挂载刚体组件的碰撞体。 静态碰撞体通常用于制作关卡中固定不动的地形，障碍物等。刚体碰撞体动力学刚体碰撞体触发器触发事件// 参数为碰撞体信息，即另一个进入了该触发区域的物体的碰撞体private void OnTriggerEnter(Collider other) {}private void OnTriggerStay(Collider other) {}private void OnTriggerExit(Collider other) {}物理材质弹性系数 弹性系数的值一般不宜超过0.9，超过1则表示反弹力会比作用力本身还大。不考虑阻力的情况下角色就永远停不下来了，这既不符合现实中的物理理念，又容易浪费计算资源，进而造成各种bug。" }, { "title": "Csharp委托和事件", "url": "/posts/CSharp%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6/", "categories": "", "tags": "", "date": "2020-08-05 00:00:00 +0800", "snippet": "高阶函数 接收委托类型（函数指针）参数的函数称为高阶函数, 高阶函数不仅可以接收函数参数, 也可以返回新的函数.Delegate 委托即是在没有函数指针的C#托管代码中实现回调函数的功能。所有函数指针功能都以委托的方式来完成。委托可以视为一个更高级的函数指针。 委托是一种特殊的类，本质上是一种函数类型，可以定义在类的外面。 如果委托的声明嵌入到类中，就称为了嵌套类型。如果仅在某个包容类中使用这个委托，就要考虑嵌套委托。 委托定义了在代码中处理事件的模式。这几乎完全消除了写轮询例程的必要。 委托不是一种类似于 float, List 等预定义好的类型，委托是我们定义的类类型，使用 delegate 关键词定义一个委托相当于定义一个继承自 System.MulticastDelegate 的类。 要使用定义好的委托需要继续定义这个委托类型的实例。// 1. 声明委托类型public delegate void Processor(string param);// 2. 定义一个方法给委托使用void PrintString(string x) {}// 3. 创建委托实例Processor proc = PrintString;// 4. 使用委托实例里的三个函数调用委托proc.Invoke(&quot;hello world&quot;); //直接调用proc.BeginInvoke(&quot;hello world&quot;); // 异步开始调用proc.EndInvoke(&quot;hello world&quot;); // 结束异步调用预定义委托 几乎不需要自己声明委托，使用合适的预定义委托，除非能够大大提高代码的可读性。Predicate 谓词指：获取一个实参并返回 bool 值的委托表达式。 通常用谓词筛选或识别集合中的数据项。即向谓词传递一个数据项，它返回true或false指出该项是否符合条件。 接受一个T类型的对象p, 返回针对这个对象的某个条件是否成立(true/false)public delegate bool Predicate&amp;lt;in T&amp;gt;(T obj) {}Predicate&amp;lt;T, bool&amp;gt; predicate; // 谓词，返回boolAction 行动只执行一些逻辑，不返回值。public delegate void Action&amp;lt;in T1, in T2, ...&amp;gt;(T1 args, T2 args, ...)；Action&amp;lt;int, string...&amp;gt; action; // 事件，返回voidFunc 方法的最后一个参数为返回值。public delegate TResult Func&amp;lt;in T, out TResult&amp;gt;(T arg)Func&amp;lt;int,bool&amp;gt; func; // 函数，最后一个参数类型为返回类型委托继承链 所有委托总是派生自 System.MulticastDelegate 类，MulticastDelegate 又派生自 System.Delegate。 Delegate 是一个抽象基类，它引用静态方法或引用类实例及该类的实例方法。只有系统和编译器可以显式地从 Delegate 类派生出委托类型。 MulticastDelegate：是一个继承于Delegate的类，其拥有一个带有链表格式的委托列表，该列表称为调用列表，在调用多路广播委托时，将按照调用列表中的委托出现的顺序来同步调用这些委托。平常我们声明一个delegate的类型，都是继承于MulticastDelegate类的(注意：不能显式地从此类进行派生。这点与Delegate类是一样的，只有系统和编译器也可以显示地进行派生）。多播委托 多播委托不止可以引用一个方法，它可以引用一系列的方法，这些方法将按照注册顺序依次调用。（不是同时，它们全部在一个执行线程上依次调用） 注册的方法依次执行，但执行顺序是不能保证的，不一定按照先来后到的顺序调用。编程时不能依赖特定的调用顺序。 通过多播委托，单个事件的通知可以发布给多个订阅者。方法组 方法组是一组方法的名称（可能只是一个）。 把方法名作为实参传递给委托形参时，从方法组向委托类型的转换会自动创建新的委托对象；所以，传参时不需要再单独定义委托对象。// 声明委托类型public delegate bool Comparer(int first, int second);// 声明高阶函数public void BubbleSort(int[] items, Comparer compare){}// 比较方法（谓词）public bool GreaterThan(int first, int second){}// 传统调用方法，手动创建委托对象BubbleSort(items, new Comparer(GreaterThan));// 使用方法组调用，自动创建委托对象BubbleSort(items, GreaterThan);本地函数 可以创建嵌套方法，并将方法名用作委托。Lambda Lambda 表达式名字的来源是 函数的λ演算系统。 Lambda 表达式是在委托的基础上构建起来的，它提供了比委托更优雅和简洁的语法。 Lambda 表达式的形参列表中的类型可以省略，利用了编译器的类型推断。// 无参数 语句lambdagetUserInput = () =&amp;gt; { return &quot;xxx&quot;;}// 单个参数 语句lambda, 参数圆括号可以省略processes.GetProcesses().Where( process =&amp;gt; { return process.WorkingSet &amp;gt; 100 });// 多参数 语句lambdaBubbleSort(items, (first, second) =&amp;gt; { return first &amp;lt; second; });// 表达式lambda,只包含要返回的表达式，没有语句块BubbleSort(items, (first, second) =&amp;gt; first &amp;lt; second);外部变量 在Lambda表达式外部声明的局部变量（包括包容方法的参数）称为该Lambda的外部变量。如果Lambda表达式主体使用一个外部变量，那么就说该变量被该Lambda表达式捕获。 编译器把被捕捉的局部变量作为生成的lambda表达式辅助类（闭包）的实例字段实现，从而延长了其生存期。所有使用局部变量的地方都改为使用那个字段。从而被捕获的外部变量的生存期超过了它的作用域，至少延长到了和委托对象一样长。 被Lambda捕捉到的是变量，而不是创建委托实例时该变量的值。 在Lambda外部对变量的更改在Lambda内部是可见的，反之亦然。闭包 Closure 闭包：闭包是为Lambda生成的一个 C#类，其中包含一个表达式及对该表达式进行求值所需要的变量。循环变量 foreach认为每一次循环变量都应该是“新的变量”，所以每次创建委托,捕捉到的都是不同的变量，不共享同一个变量。 但for循环在语句头中声明的任何循环变量在被捕捉时，都被看成同一个外部变量。 以下两种写法等价：var items = new string[] { &quot;Moe&quot;, &quot;Larry&quot;, &quot;Curly&quot;};var actions = new List&amp;lt;Action&amp;gt;();foreach(string item in items){ actions.Add( () =&amp;gt; Debug.Log(item); );}for(int i = 0; i &amp;lt; items.Count; i++) { int index = i; actions.Add( () =&amp;gt; Debug.Log(items[index]));}表达式树不太熟，用到的时候再看资料。 表达式树是对象，允许传递编译器对Lambda表达式的分析。 Where()方法获得的表达式树可转换成SQL查询并传给数据库。Event观察者模式[[观察者模式]]事件 C# delegate 关键词用于声明一个委托类型（函数类型）。 C# event 关键词可以把一个委托实例封装为事件。 事件是对委托实例的一种特殊封装 ，实现了发布者，订阅者模式。通过[[多播委托]]，单个事件的通知可以发布给多个订阅者。事件对委托的封装对订阅的封装 不允许使用 = 赋值操作符，以避免不小心清空整个委托链，取消了其他订阅者。 外部类只能使用 += 或 -= 向发布者添加或删除对事件的订阅。对发布的封装 事件相比于委托，能够确保只有包容类才能发布事件通知。public class MouseManager : MonoBehaviour { public event Action&amp;lt;string&amp;gt; OnMouseClicked; if (Physics.Raycast(ray, out hitInfo)) { // 使用空条件操作符调用委托 OnMouseClicked?.Invoke(hitInfo.point); }} MouseManager.Instance.OnMouseClicked += MoveToTarget;public void MoveToTarget(Vector3 target){ agent.destination = target;}UnityEventUnityEvent Unity事件是 [[Delegate]] 的简单封装。 事件支持多次添加同一个订阅函数，添加几次就会调用几次。这种设计虽然灵活，但有时也会造成不小心订阅了很多次的情况。 使用 Serializable 可以在Editor中 AddListener。 开发时应当尽量使用UnityEvent，因为这样不仅符合惯例，而且可以获得更多便利。无参数事件using UnityEngine.Events;public UnityEvent JumpEvent;JumpEvent.AddListener(FuncName);JumpEvent.RemoveListener(FuncName);JumpEvent?.Invoke();自定义参数事件 泛型版本的 UnityEvent 都是抽象类型, 要使用的话, 需要自己声明一个类继承之, 然后再实例化该类才可以使用.// // 泛型参数类型就是Invoke函数时传入的参数[Serializable]public class EventVector3 : UnityEvent&amp;lt;Vector3&amp;gt; {}// 定义变量public EventVector3 OnMouseClicked; // 注册回调函数OnMouseClicked.AddListener(FuncName);// 移除回调函数OnMouseClicked.RemoveListener(FuncName);// 触发回调函数OnMouseClicked?.Invoke(Vector3.zero);UnityAction UnityAction仅仅是预定义好的委托类型。 类似：[[Action]]namespace UnityEngine.Events{ public delegate void UnityAction(); public delegate void UnityAction&amp;lt;T0&amp;gt;(T0 arg0); public delegate void UnityAction&amp;lt;T0, T1&amp;gt;(T0 arg0, T1 arg1); public delegate void UnityAction&amp;lt;T0, T1, T2&amp;gt;(T0 arg0, T1 arg1, T2 arg2); public delegate void UnityAction&amp;lt;T0, T1, T2, T3&amp;gt;(T0 arg0, T1 arg1, T2 arg2, T3 arg3);}" }, { "title": "刚体", "url": "/posts/%E5%88%9A%E4%BD%93/", "categories": "", "tags": "", "date": "2020-08-04 00:00:00 +0800", "snippet": "刚体参数刚体 刚体是在任何力的作用下，体积和形状都不发生改变的物体，是一种理想模型。 添加Rigidbody组件可以使物体具备物理属性，使其运动符合物理规律。 通过刚体控制物体移动，多用于2D游戏，空洞骑士就是用的刚体驱动? 3D游戏有很多细节问题，上楼梯，容易卡在障碍物中等，不适于直接用刚体驱动。应该用[[角色控制器]]。质心(重心) 如果受力的方向通过了该物体的质心，物体就不会获得角速度。 如果受力的方向错过了质心，那么物体就会有旋转的趋势。质心到受力线的距离越远，旋转的趋势就越强。// 设置centerOfMass就可以指定重心了（本地坐标系）rigid.centerOfMass = new Vector3(0, -1, 0);质量 Mass 刚体的质量越大，越难改变其运动状态（移动+旋转）。线性阻尼 Drag 阻尼可以使物体慢慢停下来。角阻尼 Angular Drag 角阻尼可以使刚体慢慢的停止旋转。 角阻尼越大，物体越不容易转动。冲量 冲量 = 力 * 时间Is Kinematic kinematic - 运动学刚体。 勾选此项，物体由动力学刚体变为运动学刚体。 动力学刚体自身会受到力，碰撞，或者关节的影响。 运动学刚体自身不受力，碰撞，或者关节的控制，完全由动画或者代码([[Transform]], [[Unity-NavMesh]])驱动。但运动学刚体可以通过碰撞或者关节影响其他刚体的运动。 简言之，两者的区别就是本身的运动会不会受到力的影响。 Collision DetectionDiscreteContinuous 高速飞行物体的路径在空间中是一些离散的点，连续碰撞检测方式会通过这些路径点之间的连线检查是否碰撞到物体。使用刚体控制物体的移动给物体施加力 力作用在物体上会产生加速度，加速度会引起速度的变化。 用力控制物体运动的思路在牛顿力学的框架下。AddForce (Force) -默认 使用 AddForce 施加力就是从物体的质心位置施加力。 Force 模式，向刚体施加连续的力（意味着物体受到force参数的力，时间为一帧的时间(0.02s)）。 考虑其质量，即同样的力施加在越重的物体上产生的加速度越小。private float force = 3f;private void FixedUpdate(){ float horz = Input.GetAxis(&quot;Horizontal&quot;); float vert = Input.GetAxis(&quot;Vertical&quot;); Vector3 moveDirection = new Vector3(horz, 0, vert); moveDirection = moveDirection.normalized; // 力的持续时间为一个物理帧间隔（默认0.02秒） rigidbody.AddForce(moveDirection * force); // 约束速度的最大值 rigidbody.velocity = new Vector3(Vector3.ClampMagnitude(rigidbody.velocity, 5f));)}AddForce (Impulse) Impulse 模式，向刚体施加瞬时的力（相当于物体瞬间获得受到force参数的力影响一秒钟时间的效果），考虑其质量，即同样的力施加在越重的物体上产生的加速度越小。 一般用于爆炸等效果。rigidbody.AddForce(moveDirection * force, ForceMode.Impulse);AddForceAtPosition 第二个参数为施加力的位置，以世界坐标表示，非相对坐标。 如果位置不同于质心，会使刚体产生旋转的效果。rigid.AddForceAtPosition(force, position, mode);直接改变velocity 瞬间给物体一个恒定的速度，将物体提升至该速度。 直接修改速度，可以跳过加速度引起速度变化的步骤，对速度进行控制。private float speed = 10f;private void FixedUpdate(){ float horz = Input.GetAxis(&quot;Horizontal&quot;); float vert = Input.GetAxis(&quot;Vertical&quot;); Vector3 moveDelta = new Vector3(horz, 0, vert); rigidbody.velocity = speed * moveDelta;}实现二段跳private void Update(){ if (Input.GetButtonDown(&quot;Jump&quot;)) { // 在跳跃时先将角色的纵向速度直接设置为0 rigid.velocity = new Vector3(rigid.velocity.x, 0, rigid.velocity.z); // 然后再施加垂直跳跃力 rigid.AddForce(new Vector3(0, 100, 0)); }}使用刚体控制物体的旋转角速度 angularVelocity 可以直接修改刚体的角速度让刚体旋转。 角速度的三个分量分别代表沿x轴、y轴和z轴的旋转速度。 单位=弧度/秒。private void Update(){ if (Input.GetKeyDown(KeyCode.R)) { rigid.angularVelocity = new Vector3(0, 60, 0); }}" }, { "title": "Csharp对象构建顺序", "url": "/posts/CSharp%E5%AF%B9%E8%B1%A1%E6%9E%84%E5%BB%BA%E9%A1%BA%E5%BA%8F/", "categories": "", "tags": "", "date": "2020-07-30 00:00:00 +0800", "snippet": "内存初始化顺序new操作符内部和构造函数是像下面这样交互的。new操作符从内存管理器获取“空白”内存，按如下顺序初始化这块内存。调用构造函数时，将对“空白”内存的引用作为隐式的this参数传给构造函数。构造函数链剩余的部分开始执行，在构造函数之间传递引用。这些构造函数都没有返回类型（行为都像是返回void）。构造函数链上的执行结束后，new操作符返回内存的引用。现在，该引用指向的内存处于完成初始化的形式。构造某个类型的首个实例时由先到后系统所做的工作：执行静态变量初始化 把存放静态变量的空间清零 执行静态变量的初始化语句（声明时直接初始化）执行静态构造函数 执行基类的静态构造函数 执行本类的静态构造函数执行实例变量初始化 把存放实例变量的空间清零 执行实例变量的初始化语句（声明时直接初始化）执行实例构造函数 执行基类的实例构造函数 执行本类的实例构造函数执行对象初始化器 执行对象初始化器，集合初始化程序" }, { "title": "Csharp String", "url": "/posts/CSharp-String/", "categories": "", "tags": "", "date": "2020-07-25 00:00:00 +0800", "snippet": "C#中的string几种不同的字符串插值字符串 $ $@可以同时使用string name = &quot;XXX&quot;;string school = &quot;YYY&quot;;Debug.Log($&quot;demo {name} {school}&quot;); 格式化字符串中的数值要.ToString()。为了解读内插字符串，系统需要创建由System.Object引用所构成的数组，以便将调用方所要输出的值放在这个数组里面，并交给由编译器所生成的方法去解读。但int属于值类型，要想把它当成System.Object来用，就必须装箱。此外，该方法的代码还需要调用ToString()，而这实际上相当于在箱子所封装的原值上面调用，也就是说，相当于编译器生成了这样的代码：int i = 23;Console.WriteLine(i);// to -------------------------int i = 23;object o = i;Console.WriteLine(o.ToString());// 如果想避免装箱和拆箱，就需要提前把这些值手工地转换成string，然后传给WriteLine：Console.WriteLine(i.ToString());无需转义逐字字符串 @ @字符串如果要输出 &quot;, 需要 &quot;&quot;转义，&quot;&quot; 是唯一需要转义的，其他任何字符都不需要转义，而是直接输出。 $@可以同时使用Debug.Log(@&quot;demo \\\\\\ &quot;);复合格式化字符串 不同的语言语句顺序可能不同，所以本地化字符串不能简单的使用加法操作符连接。如果是运行时构造字符串，可以使用上边的插值字符串。 但语言本地化一般会把字符串移动到某个资源文件中，这种情况下就没办法使用字符串插值了。在这种情况下，应该使用复合格式化。Debug.Log(string.Format(&quot;demo {0} {1}&quot;, name, school);字符串操作替换字符串str = str.Replace(&quot;.prefab&quot;, &quot;&quot;);比较字符串// 不区分大小写比较两个字符串// 左小右大&amp;lt;0，相等=0，左大右小&amp;gt;0int comparison = string.Compare(&quot;str&quot;, &quot;STR&quot;, true);检索字符(串)索引位置// 返回&quot;\\\\&quot;字符在此实例中第一个出现的索引位置// 从左到右搜索，下标是从0开始，如果未找到则返回-1.int index = str.IndexOf(&quot;\\\\&quot;);// 返回&quot;\\\\&quot;在此实例中最后一个出现的索引位置// 从右向左搜索，第一次出现的&quot;\\\\&quot;的位置，如果未找到则返回-1.int index = str.LastIndexOf(&quot;\\\\&quot;, 7);截取字符串// 表示从下标7开始，截取长度为2的字符串// Substring(7)表示从下标7开始，一直截取到字符串末尾string subStr = str.Substring(7,2)。解析数值字符串 由于未定义从字符串到数值类型的转换，因此需要使用像TryParse()这样的方法。每个数值数据类型都包含一个TryParse()方法，允许将字符串转换成对应的数值类型。bool success = int.TryParse(&quot;123&quot;, out int a);bool success = double.TryParse(&quot;123.456&quot;, out double b);bool success = float.TryParse(&quot;123.456&quot;, out float c);格式化字符串基本语法 [复合格式设置 Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/standard/base-types/composite-formatting) // 十六进制输出数字Debug.Log($&quot;0x{42:X}&quot;);null和”“空字符串 null 意味着变量无任何值，string不指向任何引用. &quot;&quot; 表示一个空字符串. 可以给null和”“不同的含义，比如将null解释称“家庭电话未知”，将”“解释成“无家庭电话”。字符串长度 字符串长度不能更改，因为字符串不可变（immutable）。 因为字符串不可变，所以每次调用字符串的接口都是返回一个新的字符串，必须接收返回值，不然没有意义，比如 string text = text.ToUpper();StringBuilder命名空间 System.Text.StringBuilderstring的缺点 [[String]] 的值是不可变的，每次对[[String]] 的操作都会生成新的 [[String]] 对象，然后指向新的对象。 效率低下，大量浪费内存空间。StringBuilder的优点 StringBuilder 是可变的，且是线程安全的。每次操作不会生成新的对象，而是修改缓冲区的数据。 每个 StringBuilder 对象都有一定的缓冲区容量。StringBuilder的局限性 StringBuilder 只能减少字符串中间状态的分配，不能免除字符串的内存分配。在执行 ToString() 时还是会重新分配一个字符串。" }, { "title": "Unity Transform", "url": "/posts/Unity-Transform/", "categories": "", "tags": "", "date": "2020-04-22 00:00:00 +0800", "snippet": "移动 适用于既没有物理系统，对移动又没有特殊要求的情况。 不易处理障碍物阻挡的问题。private float speed = 10f;float v = Input.GetAxis(&quot;Horizontal&quot;);float h = Input.GetAxis(&quot;Horizontal&quot;);float vOffset = v * Time.deltaTime * speed;float hOffset = h * Time.deltaTime * speed;// 世界坐标系下移动Vector3 moveDelta = new Vector3(vOffset, 0, hOffset);transform.position += moveDelta;transform.Translate(moveDelta, Space.World);// 朝物体z轴方向移动transform.position += transform.forward; transform.Translate(Vector3.forward, Space.Self);// 朝世界坐标z轴方向移动transform.position += Vector3.forward;transform.Translate(Vector3.forward, Space.World); 同时设置位置和旋转transform.SetPositionAndRotation();缩放旋转 Unity使用左手坐标系，所以旋转正方向是顺时针方向 rotation 考虑到了所有父级叠加的旋转量，是世界空间的最终旋转量。直接设置旋转角度// localRotation 是 inspector面板看到的旋转量，相对于父对象。transform.localRotation = Quaternion.Euler(0, 0, -30);累计旋转量 自身累积（cumulative）旋转量，增量旋转 void Update(){ // 每秒旋转22.5度 transform.Rotate(0f, 22.5f * Time.deltaTime, 0f);} 绕某点累积旋转 绕某点累积（cumulative）旋转的方法： // point为世界空间中的点// axis为旋转轴// angle为旋转角度transform.RotateAround(point, axis, angle); 看向某个对象transform.LookAt(attackTarget.transform);分次应用旋转 [[四元数]]相乘，应用多次旋转，结合父级的旋转量 // 四元数相乘的顺序，先应用自身N，再应用父级... ...321（顶级）。// 所以乘法顺序为 rotation = 123.....N。Quaternion rotation = Quaternion.Euler(0, 0, -30);transform.localRotation = grandTrans.localRotation * parentTrans.localRotation * rotation; 坐标变换本地坐标变换到世界坐标 要注意 w 分量的取值， w=0 会忽略 position// 使用 TransformPoint 函数Vector3 worldPos = transform.parent.TransformPoint(localPosition);// 使用 localToWorldMatrix 矩阵// 变换向量 w = 0， 变换坐标 w = 1worldPos = transform.localToWorldMatrix * new Vector4(localPos.x, localPos.y, localPos.z, 1);// 使用 Matrix4x4 静态类构建TRS矩阵变换 （ Translation-Rotation-Scale）Matrix4x4 trs = Matrix4x4.TRS(position, rotation, scale);worldPos = trs * new Vector4(localPos.x, localPos.y, localPos.z, 1);世界坐标变换到本地坐标Vector4 worldPos = new Vector4(x, y, z, 1);localPos = transform.InverseTransformPoint(worldPos);localPos = transform.worldToLocalMatrix * worldPos;本地向量变换成世界空间向量transform.TransformDirection();世界空间向量变换成本地向量transform.InverseTransformDirection();修改自己的层级 修改层级关系的几个函数transform.SetAsFirstSibling(); // 层级最上（最先渲染）transform.SetSiblingIndex(i);transform.SetAsLastSibling(); // 层级最下（最后渲染）操作子对象// 获取子对象的个数int childCount = transform.childCount;// 通过名字获取子对象Transform child = transform.Find(&quot;Text&quot;);// 遍历第一层子对象(不包括自身和孙子节点)foreach(Transform child in transform){ Debug.Lod(&quot;Child: &quot; + child.name);}// 通过名字查找子孙对象private Transform DeepFindChild(Transform root, string name){ Transform result = null; result = root.Find(name); if (result == null) { foreach(Transform transform in root) { result = DeepFindChild(transform, name) { if (result != null) { return result; } } } } return result;}// 遍历所有子孙对象（包括自身和孙子节点）Transform[] children = GetComponentsInChildren&amp;lt;Transform&amp;gt;();foreach(Transform child in children){ Debug.Log(&quot;Child or Self: &quot; + child.name);}获取组件Animator anim = GetComponent&amp;lt;Animator&amp;gt;();// 获取自身和其所有子孙对象身上的所有组件Animator[] animators = GetComponentsInChildren&amp;lt;Animator&amp;gt;();不能直接对 transform.position.y赋值 transform.position是一个属性，提供了get和set方法，transform.position实际上相当于调用了一个函数，该函数返回了一个Vector3[[CS-值类型]]的拷贝，不是一个变量（variable）直接修改一个这样的临时值是无意义的。 归根结底是因为transform.position返回的是一个值类型的临时量，不是因为它是一个属性（其实提供了set方法）" }, { "title": "Monobehaviour生命周期", "url": "/posts/MonoBehaviour%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/", "categories": "", "tags": "", "date": "2020-04-20 00:00:00 +0800", "snippet": "" }, { "title": "洗牌算法", "url": "/posts/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/", "categories": "", "tags": "", "date": "2020-04-12 00:00:00 +0800", "snippet": " public static void Shuffle&amp;lt;T&amp;gt;(this T[] array) { int n = array.Length; while (n &amp;gt; 1) { var k = Random.Range(0, n--); (array[n], array[k]) = (array[k], array[n]); } } 令 n = 数组的长度。 在 0 ~ n-1 之间随机取一个数，把它和最后一个数交换。 使 n -1，重复以上步骤。 " }, { "title": "Acw 836 合并集合", "url": "/posts/ACW-836-%E5%90%88%E5%B9%B6%E9%9B%86%E5%90%88/", "categories": "", "tags": "", "date": "2019-01-15 00:00:00 +0800", "snippet": "题目一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。现在要进行 m 个操作，操作共有两种： M a b，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作； Q a b，询问编号为 a 和 b 的两个数是否在同一个集合中；输入格式第一行输入整数 n 和 m。接下来 m 行，每行包含一个操作指令，指令为 M a b 或 Q a b 中的一种。输出格式对于每个询问指令 Q a b，都要输出一个结果，如果 a 和 b 在同一集合内，则输出 Yes，否则输出 No。每个结果占一行。输入样例：4 5M 1 2M 3 4Q 1 2Q 1 3Q 3 4输出样例：YesNoYes题解 把数看作图的结点，M操作就是把结点连接起来，Q就是求a b是否在图的同一个连通分量中。 // 构造图 unordered_map&amp;lt;int, vector&amp;lt;int&amp;gt;&amp;gt; tree; if (ins == &#39;M&#39;) { auto iter = find(tree[a].begin(),tree[a].end(),b); if (iter == tree[a].end() ) { tree[a].push_back(b); // 构造无向图，存两条边 tree[b].push_back(a); // 此题需要构造无向图，否则的话从a不一定能搜索到b } } // 遍历图，看是否在同一个连通分量中 // BFS - BFS递归栈可能很深，导致内存爆掉 // Memory Limit Exceeded void bfs(int a, int father, int b) { if (a == b) { found = true; return; } for(auto n : tree[a]) { if (n == father) continue; bfs(n, a, b); } } // DFS - 同样很慢，数据量太大时会超时 bool dfs(int a, int f, int b) { queue&amp;lt;int&amp;gt; q; // 辅助队列 unordered_map&amp;lt;int, int&amp;gt; father; // 记录遍历时的父结点 unordered_map&amp;lt;int, bool&amp;gt; visited; // 记录结点是否访问过 father[a] = f; q.push(a); visited[a] = false; while (q.empty() == false) { int root = q.front(); // front取队头元素 if (root == b) { return true; } visited[root] = true; q.pop(); // pop 弹出队头元素 for(auto n : tree[root]) { if (n == father[root]) continue; if (visited[n] == true) continue; father[n] = root; q.push(n); visited[n] = false; } } " }, { "title": "Pat 1498 求树最深的根", "url": "/posts/PAT-1498-%E6%B1%82%E6%A0%91%E6%9C%80%E6%B7%B1%E7%9A%84%E6%A0%B9/", "categories": "", "tags": "", "date": "2019-01-14 00:00:00 +0800", "snippet": "题目一个无环连通图可以被视作一个树。树的高度取决于所选取的根节点。现在，你要找到可以使得树的高度最大的根节点。它被称为最深的根。输入格式第一行包含整数 N，表示节点数量。节点编号为 1∼N。接下来 N−1 行，每行包含两个整数，表示两个节点之间存在一条边。输出格式输出最深的根的节点编号。如果最深的根不唯一，则按照从小到大的顺序，将它们依次输出，每个占一行。如果给定的图不是树，输出 Error: K components，其中 K 是图中连通分量的数量。数据范围$1 \\le N \\le 10^4$输入样例1：51 21 31 42 5输出样例1：345输入样例2：51 31 42 53 4输出样例2：Error: 2 components题解 // 数据结构：无向图存两条有向边 vector&amp;lt;int&amp;gt; graph[N]; // 图的临接表存储 for(int i = 1; i &amp;lt; node_count; i++) { int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; graph[a].push_back(b); // 无向图存两条边 graph[b].push_back(a); } // 判断是否只有一个连通分量（connected components in the graph） // 并查集 // BFS / DFS 每次遍历结束要查看是否还有没访问的边，调用BFS/DFS的次数就是连通分量数 bool visited[N]; bool check_connected() { memset(visited, false, sizeof(visited)); // #include &amp;lt;cstirng&amp;gt; int component = 0; for(int i = 1; i &amp;lt;= node_count; i++) { if (!visited[i]) { component++; visit(i, -1); } } return component == 1; } void visit(int node, int father) { visited[node] = true; for(int n : graph[node]) { if (n == father) continue; if (visited[n]) continue; visit(n, node); } } // 枚举所有的点，找到最大深度的顶点。 vector&amp;lt;int&amp;gt; max_depth_root; int max_depth = 0; for(int i = 1; i &amp;lt;= node_count; i++) { int depth = cal_max_depth(i, -1); if (depth &amp;gt; max_depth) { max_depth = depth; max_depth_root.clear(); max_depth_root.push_back(i); } else if(depth == max_depth) { max_depth_root.push_back(i); } } int cal_max_depth(int root, int father) { int depth = 0; for(int n : graph[root]) { if (n == father) continue; depth = max(depth, cal_max_depth(n, root) + 1); } return depth; } " }, { "title": "Pat 1497 树的遍历", "url": "/posts/PAT-1497-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/", "categories": "", "tags": "", "date": "2019-01-13 00:00:00 +0800", "snippet": "题目一个二叉树，树中每个节点的权值互不相同。现在给出它的后序遍历和中序遍历，请你输出它的层序遍历。输入格式第一行包含整数 N，表示二叉树的节点数。第二行包含 N 个整数，表示二叉树的后序遍历。第三行包含 N 个整数，表示二叉树的中序遍历。输出格式输出一行 N 个整数，表示二叉树的层序遍历。输入样例：72 3 1 5 7 6 41 2 3 4 5 6 7输出样例：4 1 6 3 5 7 2题解 给定二叉树的中序和后序遍历序列，输出二叉树的层序遍历结果。 此题中的二叉树结点的权值不一定是0～N之间的值，也可能是10000000等很大的值。 不能用数组存pos和l,r // 设计二叉树存储结构 vector&amp;lt;int&amp;gt; post_order(N, 0); // 存储后序序列 vector&amp;lt;int&amp;gt; in_order(N, 0); // 存储中序序列 unordered_map&amp;lt;int, int&amp;gt; pos; // 存储中序序列每个元素的位置 unordered_map&amp;lt;int, int&amp;gt; l, r;// 记录二叉树的左孩子,右孩子 // 构造二叉树 // 构造过程是一个不断划分的过程， 以root为中心，划分为左右子树 // il, ir, pl, pr 分别指中序，后序序列的序号 int buildBiTree(int il, int ir, int pl, int pr) { int root = postOrder[pr]; int k = pos[root]; if (il &amp;lt; k) { l[root] = buildBiTree(il, k-1, pl, pl+k-il-1); } if (ir &amp;gt; k) { r[root] = buildBiTree(k+1, ir, pr-(ir-k), pr - 1); } return root; } // 层序遍历输出结果（借助于队列，其实就是BFS） void bfs(int root) { queue&amp;lt;int&amp;gt; q; q.push(root); int count = 0; while (q.empty() == false) { auto node = q.front(); if (count == 0) { cout &amp;lt;&amp;lt; node; } else { cout &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; node; } count++; q.pop(); if (l.count(node)) { q.push(l[node]); } if (r.count(node)) { q.push(r[node]); } } } " }, { "title": "Pat 1476 数叶子结点", "url": "/posts/PAT-1476-%E6%95%B0%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9/", "categories": "", "tags": "", "date": "2019-01-12 00:00:00 +0800", "snippet": "题目家庭关系可以用家谱树来表示，给定一个家谱树，你的任务是找出其中没有孩子的成员。输入格式第一行包含一个整数 N 表示树中结点总数以及一个整数 M 表示非叶子结点数。接下来 M 行，每行的格式为：ID K ID[1] ID[2] ... ID[K]ID 是一个两位数字，表示一个非叶子结点编号，K 是一个整数，表示它的子结点数，接下来的 K 个 ID[i] 也是两位数字，表示一个子结点的编号。为了简单起见，我们将根结点固定设为 01。所有结点的编号即为 01, 02, 03, … ,31, 32, 33, …, N。输出格式输出从根结点开始，自上到下，树的每一层级分别包含多少个叶子节点。输出占一行，整数之间用空格隔开。数据范围0 &amp;lt; N &amp;lt; 100输入样例：2 101 1 02输出样例：0 1样例解释该样例表示一棵只有 2 个结点的树，其中 01 结点是根，而 02 结点是其唯一的子节点。因此，在根这一层级上，存在 0 个叶结点；在下一个级别上，有 1 个叶结点。所以，我们应该在一行中输出0 1。题解 此题大概意思是给定一棵树(图)，求树的每一层的叶子结点数。 根据输入数据构造出树 vector&amp;lt;int&amp;gt; node[N] 用DFS求树的每层叶子结点数，从根结点01开始： 如果该结点是叶结点，该层叶子结点数+1，返回； 如果该结点不是叶结点，DFS遍历此结点的所有孩子结点。 // 根据输入构造树 vector&amp;lt;int&amp;gt; node[N]; // 采用临接表存储树 while (m--) { int id, k, ch; cin &amp;gt;&amp;gt; id &amp;gt;&amp;gt; k; while (k--){ cin &amp;gt;&amp;gt; ch; node[id].push_back(ch); } } // 深度优先搜索遍历树 void dfs(int id, int depth) { if (node[id].size() == 0) { // 递归出口 leaveNum[depth]++; if (depth &amp;gt; maxDepth) { maxDepth = depth; } return; } else { for(auto n : node[id]) { // 子问题调用 bfs(n, depth + 1); } } } " }, { "title": "Pat 1474 多项式a加b", "url": "/posts/PAT-1474-%E5%A4%9A%E9%A1%B9%E5%BC%8FA%E5%8A%A0B/", "categories": "", "tags": "", "date": "2019-01-11 00:00:00 +0800", "snippet": "题目给定两个多项式 $A$ 和 $B$，计算 $A+B$ 的结果。输入格式共两行，每行包含一个多项式的信息，格式如下：$K\\ N_1\\ a_{N_1}\\ N_2\\ a_{N_2}\\ ……\\ N_k\\ a_{N_k}$其中，$K$ 表示多项式中非零项的数量，$N_i$ 和$a_{N_i}$ 分别表示其中一个非零项的指数和系数。输出格式按照与输入相同的格式，输出 A+B 的结果。结果中的各项的系数均保留一位小数。输入样例：2 1 2.4 0 3.22 2 1.5 1 0.5输出样例：3 2 1.5 1 2.9 0 3.2题解 解法1 #include &amp;lt;iostream&amp;gt; using namespace std; const int MAX = 1010; double a_a[MAX], b_a[MAX]; int main() { int k; // 读取第一个多项式 cin &amp;gt;&amp;gt; k; while (k--) { int n; double a; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; a; a_a[n] = a; } // 读取第二个多项式 cin &amp;gt;&amp;gt; k; while (k--) { int n; double a; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; a; b_a[n] = a; } // 相加，计算结果的项数 int count = 0; for (int i = MAX; i &amp;gt;= 0; --i) { b_a[i] += a_a[i]; if(b_a[i]) { count++; } } // 输出结果 printf(&quot;%d&quot;,count); for (int i = MAX; i &amp;gt;= 0; --i) { if (b_a[i]) { printf(&quot; %d %.1f&quot;, i, b_a[i]); } } return 0; } " }, { "title": "Pat 1559 科学计数法", "url": "/posts/PAT-1559-%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95/", "categories": "", "tags": "", "date": "2019-01-10 00:00:00 +0800", "snippet": "题目科学计数法是科学家轻松处理非常大或非常小的数字的方式。这种表示法与正则表达式 [+-][1-9].[0-9]+E[+-][0-9]+ 相匹配。整数部分恰好一位，小数部分至少一位，数字以及指数的正负必须给出，即使均为正，也要给出 +。现在给定科学计数法表示的实数 A，请你在保留所有有效数字的情况下以常规计数法输出 A。输入格式共一行，包含科学计数法表示的实数 A。输出格式输出常规计数法表示的 A，注意保留所有有效数字，包括尾部 0。数据范围输入数字的长度不超过 9999 字节，指数的绝对值不超过 9999。输入样例1：+1.23400E-03输出样例1：0.00123400输入样例2：-1.2E+10输出样例2：-12000000000##题解 先判断数符，根据+-决定是否输出负号 从 E 处 把数字分成尾数和指数 指数可以直接转换成整数（stoi） 尾数把 . 左右的部分拼起来 根据指数的正负分别输出对应的数值 #include &amp;lt;iostream&amp;gt; #include &amp;lt;map&amp;gt; using namespace std; int PRICE[24]; float CalcuPrice(int hStart, int mStart, int totalTime) { float price = 0; int firstTime = 60 - mStart; if (totalTime - firstTime &amp;gt; 0) { price += (firstTime * PRICE[hStart++]); if (hStart &amp;gt;= 24) { hStart = 0; } totalTime -= firstTime; } while (1) { if (totalTime &amp;gt;= 60) { price += 60 * PRICE[hStart++]; totalTime -= 60; if (hStart &amp;gt;= 24) { hStart = 0; } } else { price += totalTime * PRICE[hStart]; break; } } return price * 0.01; } int main() { for (int i = 0; i &amp;lt; 24; ++i) { cin &amp;gt;&amp;gt; PRICE[i]; } int n; cin &amp;gt;&amp;gt; n; map&amp;lt;string, map&amp;lt;string, string&amp;gt;&amp;gt; items; for (int i = 0; i &amp;lt; n; ++i) { string name, time, tip; cin &amp;gt;&amp;gt; name &amp;gt;&amp;gt; time &amp;gt;&amp;gt; tip; items[name][time] = tip; } for (auto i : items) { int count = 0; string onTime, offTime; bool lastOnline = false; float totalAmount = 0; for (auto j : i.second) { if (j.second == &quot;on-line&quot;) { onTime = j.first; lastOnline = true; continue; } if (j.second == &quot;off-line&quot; &amp;amp;&amp;amp; lastOnline == true) { count++; if (count == 1) { cout &amp;lt;&amp;lt; i.first &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; j.first.substr(0, 2) &amp;lt;&amp;lt; endl; } cout &amp;lt;&amp;lt; onTime.substr(3) &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; j.first.substr(3) &amp;lt;&amp;lt; &#39; &#39;; int d1 = atoi(onTime.substr(3,2).c_str()); int h1 = atoi(onTime.substr(6,2).c_str()); int m1 = atoi(onTime.substr(9,2).c_str()); int time1 = d1 * 24 * 60 + h1 * 60 + m1; int d2 = atoi(j.first.substr(3, 2).c_str()); int h2 = atoi(j.first.substr(6, 2).c_str()); int m2 = atoi(j.first.substr(9, 2).c_str()); int time2 = d2 * 24 * 60 + h2 * 60 + m2; int time = time2 - time1; float amount = CalcuPrice(h1, m1, time); printf(&quot;%d $%.2f\\n&quot;, time, amount); totalAmount += amount; lastOnline = false; continue; } } if (totalAmount != 0) { printf(&quot;Total amount: $%.2f\\n&quot;, totalAmount); } } return 0; } " }, { "title": "Pat 1593 电话账单", "url": "/posts/PAT-1593-%E7%94%B5%E8%AF%9D%E8%B4%A6%E5%8D%95/", "categories": "", "tags": "", "date": "2019-01-09 00:00:00 +0800", "snippet": "题目长途电话公司按以下规则向客户收费：拨打长途电话每分钟要花费一定的费用，具体收费取决于拨打电话的时间。客户开始拨打长途电话的时间将被记录，客户挂断电话的时间也将被记录。每个月都要给客户发送一次话费账单，账单中应包含每次通话记录以及相关收费等信息。给定一组电话记录，你的工作是为客户准备帐单。输入格式输入包含两部分：费率结构和电话记录。费率结构由一行组成，该行包含24个非负整数，分别表示从 00:00-01:00 的收费（分/分钟），从 01:00-02:00 的收费，以此类推…下一行包含一个正整数 N。接下来 N 行，每行包含一条记录。每个记录由客户名称（最多 20 个字符的字符串，不带空格），时间和日期（mm:dd:hh:mm）以及单词 on-line 或 off-line 组成。所有日期都在同一个月内，每个 on-line 记录都与按时间顺序排列的同一位客户的下一条记录配对，但前提是这条记录是 off-line。所有未与 off-line 记录配对的 on-line 记录以及未与 on-line 记录配对的 off-line 记录都必须忽略。输入中至少包含一个成功的配对。同一客户在同一时间不会有两个或以上的电话记录。使用 24 小时制记录时间。输出格式你需要为每个客户打印电话费。账单必须按照客户姓名的字母顺序（按ASCII码顺序，大写字母在前，小写字母在后）打印。对于每个客户，首先以示例显示的格式在一行中打印客户名称和帐单月份。然后，对于每个通话时间段，在一行中分别打印开始和结束时间和日期（dd:hh:mm），持续时间（以分钟为单位）和通话费用。通话必须按时间顺序列出。最后，以示例显示的格式打印该月的总费用。注意，没有任何有效通话记录的客户直接忽略，不予打印账单。数据范围1≤N≤1000输入样例：10 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 1010CYLL 01:01:06:01 on-lineCYLL 01:28:16:05 off-lineCYJJ 01:01:07:00 off-lineCYLL 01:01:08:03 off-lineCYJJ 01:01:05:59 on-lineaaa 01:01:01:03 on-lineaaa 01:02:00:01 on-lineCYLL 01:28:15:41 on-lineaaa 01:05:02:24 on-lineaaa 01:04:23:59 off-line输出样例：CYJJ 0101:05:59 01:07:00 61 $12.10Total amount: $12.10CYLL 0101:06:01 01:08:03 122 $24.4028:15:41 28:16:05 24 $3.85Total amount: $28.25aaa 0102:00:01 04:23:59 4318 $638.80Total amount: $638.80题解 解法1 #include &amp;lt;iostream&amp;gt; #include &amp;lt;map&amp;gt; using namespace std; int PRICE[24]; float CalcuPrice(int hStart, int mStart, int totalTime) { float price = 0; int firstTime = 60 - mStart; if (totalTime - firstTime &amp;gt; 0) { price += (firstTime * PRICE[hStart++]); if (hStart &amp;gt;= 24) { hStart = 0; } totalTime -= firstTime; } while (1) { if (totalTime &amp;gt;= 60) { price += 60 * PRICE[hStart++]; totalTime -= 60; if (hStart &amp;gt;= 24) { hStart = 0; } } else { price += totalTime * PRICE[hStart]; break; } } return price * 0.01; } int main() { for (int i = 0; i &amp;lt; 24; ++i) { cin &amp;gt;&amp;gt; PRICE[i]; } int n; cin &amp;gt;&amp;gt; n; map&amp;lt;string, map&amp;lt;string, string&amp;gt;&amp;gt; items; for (int i = 0; i &amp;lt; n; ++i) { string name, time, tip; cin &amp;gt;&amp;gt; name &amp;gt;&amp;gt; time &amp;gt;&amp;gt; tip; items[name][time] = tip; } for (auto i : items) { int count = 0; string onTime, offTime; bool lastOnline = false; float totalAmount = 0; for (auto j : i.second) { if (j.second == &quot;on-line&quot;) { onTime = j.first; lastOnline = true; continue; } if (j.second == &quot;off-line&quot; &amp;amp;&amp;amp; lastOnline == true) { count++; if (count == 1) { cout &amp;lt;&amp;lt; i.first &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; j.first.substr(0, 2) &amp;lt;&amp;lt; endl; } cout &amp;lt;&amp;lt; onTime.substr(3) &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; j.first.substr(3) &amp;lt;&amp;lt; &#39; &#39;; int d1 = atoi(onTime.substr(3,2).c_str()); int h1 = atoi(onTime.substr(6,2).c_str()); int m1 = atoi(onTime.substr(9,2).c_str()); int time1 = d1 * 24 * 60 + h1 * 60 + m1; int d2 = atoi(j.first.substr(3, 2).c_str()); int h2 = atoi(j.first.substr(6, 2).c_str()); int m2 = atoi(j.first.substr(9, 2).c_str()); int time2 = d2 * 24 * 60 + h2 * 60 + m2; int time = time2 - time1; float amount = CalcuPrice(h1, m1, time); printf(&quot;%d $%.2f\\n&quot;, time, amount); totalAmount += amount; lastOnline = false; continue; } } if (totalAmount != 0) { printf(&quot;Total amount: $%.2f\\n&quot;, totalAmount); } } return 0; } " }, { "title": "Pat 1547 约会", "url": "/posts/PAT-1547-%E7%BA%A6%E4%BC%9A/", "categories": "", "tags": "", "date": "2019-01-08 00:00:00 +0800", "snippet": "题目大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;amp;hgsfdk d&amp;amp;Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。补充1、一对字符相同，是指在两个字符相同且在字符串的位置也相同。2、前两个字符串中第一对相同的大写英文字母，是指第一对能够正确代表日期的大写英文字母。3、前两个字符串中第二对相同的字符，是指位于代表日期的字符后面的，第一对相同的，能够正确代表小时的字符。输入格式输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。输出格式在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。输入样例：3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;amp;hgsfdk d&amp;amp;Hyscvnm输出样例：THU 14:04题解 解法1 #include &amp;lt;iostream&amp;gt; using namespace std; int main() { const string DAY[7] = {&quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;, &quot;SUN&quot;}; string s1, s2, s3, s4; cin &amp;gt;&amp;gt; s1 &amp;gt;&amp;gt; s2 &amp;gt;&amp;gt; s3 &amp;gt;&amp;gt; s4; int length = min(s1.length(), s2.length()); for (int i = 0, j = 0; i &amp;lt; length; ++i) { if (j == 0 &amp;amp;&amp;amp; s1[i] &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; s1[i] &amp;lt;= &#39;G&#39; &amp;amp;&amp;amp; s1[i] == s2[i]) { cout &amp;lt;&amp;lt; DAY[s1[i] - &#39;A&#39;] &amp;lt;&amp;lt; &#39; &#39;; j++; continue; } if (j == 1 &amp;amp;&amp;amp; s1[i] == s2[i]) { if (s1[i] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; s1[i] &amp;lt;= &#39;9&#39;) { cout &amp;lt;&amp;lt; &#39;0&#39; &amp;lt;&amp;lt; s1[i] &amp;lt;&amp;lt; &#39;:&#39;; break; } else if(s1[i] &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; s1[i] &amp;lt;= &#39;N&#39;) { cout &amp;lt;&amp;lt; s1[i] - &#39;A&#39; + 10 &amp;lt;&amp;lt; &#39;:&#39;; break; } } } length = min(s3.length(), s4.length()); for (int i = 0; i &amp;lt; length; ++i) { if (s3[i] == s4[i]) { if ((s3[i] &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; s3[i] &amp;lt;= &#39;z&#39;) || (s3[i] &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; s3[i] &amp;lt;= &#39;Z&#39;)) { printf(&quot;%02d&quot;, i); break; } } } return 0; } " }, { "title": "Pat 1557 说话方式", "url": "/posts/PAT-1557-%E8%AF%B4%E8%AF%9D%E6%96%B9%E5%BC%8F/", "categories": "", "tags": "", "date": "2019-01-07 00:00:00 +0800", "snippet": "题目不同的人对描述同一种事物的同义词的偏爱程度可能不同。例如，在说警察时，有人喜欢用 the police，有人喜欢用 the cops。分析说话方式有助于确定说话者的身份，这在验证诸如和你线上聊天的是否是同一个人十分有用。现在，给定一段从某人讲话中提取的文字，你能确定他的最常用词吗？输入格式输入共一行，包含一个字符串，以回车符 \\n 终止。输出格式共一行，输出最常用词以及其出现次数。如果常用词有多个，则输出字典序最小的那个单词。注意，单词在输出时，必须全部小写。单词是指由连续的字母和数字构成的，被非字母数字字符或行首/行尾分隔开的，连续序列。单词不区分大小写。数据范围输入字符串长度不超过 1048576，且至少包含一个大小写字母或数字。输入样例：Can1: &quot;Can a can can a can? It can!&quot;输出样例：can 题解 解法1 #include &amp;lt;iostream&amp;gt; #include &amp;lt;map&amp;gt; using namespace std; int main() { string s1; getline(cin, s1); string word; map&amp;lt;string, int&amp;gt; words; for (auto c : s1) { if ((c &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; c &amp;lt;= &#39;9&#39;) || (c &amp;gt;= &#39;a&#39;) &amp;amp;&amp;amp; c &amp;lt;= &#39;z&#39;) { word += tolower(c); } else { if (!word.empty()) { words[word]++; } word.clear(); } } if (!word.empty()) { words[word]++; } int max_count = 0; string max_word; for (auto w : words) { if(w.second &amp;gt; max_count) { max_count = w.second; max_word = w.first; } } cout &amp;lt;&amp;lt; max_word &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; max_count &amp;lt;&amp;lt; endl; return 0; } 使用哈希集合的解法 #include &amp;lt;iostream&amp;gt; #include &amp;lt;unordered_map&amp;gt; using namespace std; int main() { string s1; getline(cin, s1); string word; unordered_map&amp;lt;string, int&amp;gt; hash; for (auto c : s1) { if ((c &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; c &amp;lt;= &#39;9&#39;) || (c &amp;gt;= &#39;a&#39;) &amp;amp;&amp;amp; c &amp;lt;= &#39;z&#39;) { word += tolower(c); } else { if (!word.empty()) { hash[word]++; } word.clear(); } } if (!word.empty()) { hash[word]++; } int max_count = 0; string max_word; for (auto w : hash) { if(w.second &amp;gt; max_count || (w.second == max_count &amp;amp;&amp;amp; w.first &amp;lt; max_word)) { max_count = w.second; max_word = w.first; } } cout &amp;lt;&amp;lt; max_word &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; max_count &amp;lt;&amp;lt; endl; return 0; } " }, { "title": "Pat 1534 字符串减法", "url": "/posts/PAT-1534-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%8F%E6%B3%95/", "categories": "", "tags": "", "date": "2019-01-06 00:00:00 +0800", "snippet": "题目给定两个字符串 S1 和 S2，S=S1−S2 定义为将 S1 中包含的所有在 S2 中出现过的字符删除后得到的字符串。你的任务就是计算 S1−S2。输入格式共两行，第一行包含字符串 S1，第二行包含字符串 S2。输出格式输出共一行，表示 S1−S2 的结果。数据范围两个给定字符串的长度都不超过 104。输入样例：They are students.aeiou输出样例：Thy r stdnts. 题解 解法1 #include &amp;lt;iostream&amp;gt; using namespace std; int main() { string s1, s2, s3; getline(cin, s1); getline(cin, s2); for (auto s : s1) { auto idx = s2.find(s); if(idx == string::npos) { s3.push_back(s); // s3 += c } } cout &amp;lt;&amp;lt; s3 &amp;lt;&amp;lt; endl; return 0; } 使用哈希集合的解法 #include &amp;lt;iostream&amp;gt; #include &amp;lt;unordered_set&amp;gt; using namespace std; int main() { string s1, s2, s3; getline(cin, s1); getline(cin, s2); unordered_set&amp;lt;char&amp;gt; hash; for (auto c : s2) hash.insert(c); for (auto c : s1) { if (!hash.count(c)) { s3 += c; } } cout &amp;lt;&amp;lt; s3 &amp;lt;&amp;lt; endl; return 0; } " }, { "title": "Pat 1520 男孩和女孩", "url": "/posts/PAT-1520-%E7%94%B7%E5%AD%A9%E5%92%8C%E5%A5%B3%E5%AD%A9/", "categories": "", "tags": "", "date": "2019-01-05 00:00:00 +0800", "snippet": "题目给定 N 个学生的成绩信息，请你求出女生第一名与男生倒数第一名的分数差距。输入格式第一行输入整数 N，表示学生数量。接下来 N 行，每行包含一个学生的姓名，性别，ID和成绩。其中姓名和ID是长度不超过 10 且不包含空格的字符串。性别为 F（女）或 M（男）。成绩是一个范围在 [0,100] 的整数。保证所有学生的成绩互不相同。输出格式输出共三行。第一行输出女生第一名的姓名和ID。第二行输出男生倒数第一名的姓名和ID。第三行输出女生第一名的成绩与男生倒数第一名的成绩的差的绝对值。如果不存在某个性别的学生，则在对应行输出 Absent。在第三行输出 NA。数据范围1≤N≤101输入样例1：3Joe M Math990112 89Mike M CS991301 100Mary F EE990830 95输出样例1：Mary EE990830Joe Math9901126输入样例2：1Jean M AA980920 60输出样例2：AbsentJean AA980920NA##题解#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int main(){ int n; cin &amp;gt;&amp;gt; n; string f_name, m_name, f_id, m_id; int f_score = -1, m_score = 101; for (int i = 0; i &amp;lt; n; ++i) { string name, sex, id; int score; cin &amp;gt;&amp;gt; name &amp;gt;&amp;gt; sex &amp;gt;&amp;gt; id &amp;gt;&amp;gt; score; if (sex == &quot;F&quot;) { if (score &amp;gt; f_score) { f_name = name; f_id = id; f_score = score; } } else { if (score &amp;lt; m_score) { m_name = name; m_id = id; m_score = score; } } } if (f_score != -1) { cout &amp;lt;&amp;lt; f_name &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; f_id &amp;lt;&amp;lt; endl; } else { cout &amp;lt;&amp;lt; &quot;Absent&quot; &amp;lt;&amp;lt; endl; } if (m_score != 101) { cout &amp;lt;&amp;lt; m_name &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; m_id &amp;lt;&amp;lt; endl; } else { cout &amp;lt;&amp;lt; &quot;Absent&quot; &amp;lt;&amp;lt; endl; } if (f_score == -1 || m_score == 101) { cout &amp;lt;&amp;lt; &quot;NA&quot; &amp;lt;&amp;lt; endl; } else { cout &amp;lt;&amp;lt; abs(f_score - m_score) &amp;lt;&amp;lt; endl; } return 0;}" }, { "title": "Pat 1519 密码", "url": "/posts/PAT-1519-%E5%AF%86%E7%A0%81/", "categories": "", "tags": "", "date": "2019-01-04 00:00:00 +0800", "snippet": "题目为了准备 PAT，系统不得不为用户生成随机密码。但是有时一些数字和字母之间总是难以区分，比如 1（数字一）和 l（L 的小写），0（数字零）和 O（o 的大写）。一种解决办法是将 1（数字一）替换为 @，将 0（数字零）替换为 %，将 l（L 的小写）替换为 L，将 O（o 的大写）替换为 o。现在，你的任务就是帮助系统检查这些用户的密码，并对难以区分的部分加以修改。输入格式第一行包含一个整数 N，表示用户数量。接下来 N 行，每行包含一个用户名和一个密码，都是长度不超过 10 且不含空格的字符串。输出格式首先输出一个整数 M，表示已修改的用户密码数量。接下来 M 行，每行输出一个用户名称和其修改后的密码。用户的输出顺序和读入顺序必须相同。如果没有用户的密码被修改，则输出 There are N accounts and no account is modified，其中 N 是用户总数。如果 N=1，则应该输出 There is 1 account and no account is modified。数据范围1≤N≤1000输入样例1：3Team000002 Rlsp0dfaTeam000003 perfectpwdTeam000001 R1spOdfa输出样例1：2Team000002 RLsp%dfaTeam000001 R@spodfa输入样例2：1team110 abcdefg332输出样例2：There is 1 account and no account is modified输入样例3：2team110 abcdefg222team220 abcdefg333输出样例3：There are 2 accounts and no account is modified题解#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int main(){ int n; cin &amp;gt;&amp;gt; n; vector&amp;lt;string&amp;gt; names, passwords; string name, password; bool modified = false; for (int i = 0; i &amp;lt; n; ++i) { modified = false; cin &amp;gt;&amp;gt; name &amp;gt;&amp;gt; password; for (int j = 0; j &amp;lt; password.size(); ++j) { if (password[j] == &#39;1&#39;) { password[j] = &#39;@&#39;; modified = true; } if (password[j] == &#39;0&#39;) { password[j] = &#39;%&#39;; modified = true; } if (password[j] == &#39;l&#39;) { password[j] = &#39;L&#39;; modified = true; } if (password[j] == &#39;O&#39;) { password[j] = &#39;o&#39;; modified = true; } } if (modified) { names.push_back(name); passwords.push_back(password); } } if (names.size() &amp;gt; 0) { cout &amp;lt;&amp;lt; names.size() &amp;lt;&amp;lt; endl; for (int j = 0; j &amp;lt; names.size(); ++j) { cout &amp;lt;&amp;lt; names[j] &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; passwords[j] &amp;lt;&amp;lt; endl; } } else { cout &amp;lt;&amp;lt; &quot;There &quot;; if (n == 1) { cout &amp;lt;&amp;lt; &quot;is &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &quot; account&quot;; } else { cout &amp;lt;&amp;lt; &quot;are &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &quot; accounts&quot;; } cout &amp;lt;&amp;lt; &quot; and no account is modified&quot; &amp;lt;&amp;lt; endl; } return 0;}" }, { "title": "Pat 1478 签到与签出", "url": "/posts/PAT-1478-%E7%AD%BE%E5%88%B0%E4%B8%8E%E7%AD%BE%E5%87%BA/", "categories": "", "tags": "", "date": "2019-01-03 00:00:00 +0800", "snippet": "题目每天第一个到机房的人负责开门，最后一个从机房离开的人负责锁门。现在，给定每个人的签到与签出记录，请你找出当天开门的人以及锁门的人分别是谁。输入格式第一行包含整数 M，表示共有 M 个人的签到签出记录。接下来 M 行，每行的形式如下：ID_number Sign_in_time Sign_out_time时间以 HH:MM:SS 形式给出，ID_number 是一个长度不超过 15 的字符串。输出格式共一行，输出开门人和锁门人的ID_number，用一个空格隔开。数据范围1≤M≤10,数据保证每个人的签到时间早于签出时间，并且不会出现两个人同时签到或同时签出的情况。输入样例：3CS301111 15:30:28 17:00:10SC3021234 08:00:00 11:25:25CS301133 21:45:00 21:58:40输出样例：SC3021234 CS301133题解 用字典序直接比较时间大小 (string直接比较) #include &amp;lt;iostream&amp;gt; using namespace std; int GetTimeInSecond(string str) { int h = (str[0] - &#39;0&#39;) * 10 + (str[1] - &#39;0&#39;); int m = (str[3] - &#39;0&#39;) * 10 + (str[4] - &#39;0&#39;); int s = (str[6] - &#39;0&#39;) * 10 + (str[7] - &#39;0&#39;); return h * 3600 + m * 60 + s; } int main() { int n; cin &amp;gt;&amp;gt; n; string signInId, signOutId; int signInTime = 999999, signOutTime = 0; for (int i = 0; i &amp;lt; n; ++i) { string id, signIn, signOut; cin &amp;gt;&amp;gt; id &amp;gt;&amp;gt; signIn &amp;gt;&amp;gt; signOut; int time = GetTimeInSecond(signIn); if (time &amp;lt; signInTime) { signInTime = time; signInId = id; } time = GetTimeInSecond(signOut); if (time &amp;gt; signOutTime) { signOutTime = time; signOutId = id; } } cout &amp;lt;&amp;lt; signInId &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; signOutId; return 0; } 题解2 #include &amp;lt;iostream&amp;gt; using namespace std; int main() { int n; cin &amp;gt;&amp;gt; n; string open_id, open_time; string close_id, close_time; for (int i = 0; i &amp;lt; n; ++i) { string id, in_time, out_time; cin &amp;gt;&amp;gt; id &amp;gt;&amp;gt; in_time &amp;gt;&amp;gt; out_time; if (!i || in_time &amp;lt; open_time) { open_id = id; open_time = in_time; } if (!i || out_time &amp;gt; close_time) { close_id = id; close_time = out_time; } } cout &amp;lt;&amp;lt; open_id &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; close_id; return 0; } " }, { "title": "Pat 1477 计算数字和", "url": "/posts/PAT-1477-%E8%AE%A1%E7%AE%97%E6%95%B0%E5%AD%97%E5%92%8C/", "categories": "", "tags": "", "date": "2019-01-02 00:00:00 +0800", "snippet": "题目给定一个非负整数 N，你的任务是计算 N 的所有数字的总和，并以英语输出总和的每个数字。输入格式共一行，包含一个整数 N。输出格式共一行，用英语输出总和的每个数字，单词之间用空格隔开。输入样例：12345输出样例：one five题解 数字单词先缓存，制表。 #include &amp;lt;iostream&amp;gt; using namespace std; int main() { string n; cin &amp;gt;&amp;gt; n; int sum = 0; for (auto ch : n) { sum += ch - &#39;0&#39;; } string s_sum = to_string(sum); string word[10] = {&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;,　&quot;five&quot;,&quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;}; for (int i = 0; i &amp;lt; s_sum.size(); ++i ) { cout &amp;lt;&amp;lt; word[s_sum[i] - &#39;0&#39;]; if (i != s_sum.size() - 1) { cout &amp;lt;&amp;lt; &#39; &#39;; } } return 0; } " }, { "title": "大o表示法", "url": "/posts/%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/", "categories": "", "tags": "", "date": "2019-01-01 00:00:00 +0800", "snippet": "算法的步数 我们使用“步数”来描述运行时间。“1步”就是计算的基本单位。 可以通过测试“计算从开始到结束总共执行了多少步”来求得算法的运行时间。大 Ο 大O，即 order of，大约的意思。 大Ο、大 θ (theta) 、大 Ω (omega) 分别描述了运行时间的上界、确界和下界。 比如一个算法的时间复杂度的确界是 θ($N$)，那它的上界可以是 O($N^2$) , O($N^3$), 甚至 O($2^N$)，它的下界可以是 O(1)，和输入，问题规模是无关的。 最优、最坏和期望情况是用来描述给定输入或场景中的大 Ο 时间（确界）。 比如快排，最优 Ο($N$)， 最坏 Ο($N^2$)，期望 Ο($NlogN$)。 工业界一般用大O指代确界。 大 O 仅仅描述增长的趋势，常量不算在运行时间中，$O(2N) == O(N)$。 大 Ο 更多地表现了运行时间的规模，$Ο(N)$ 并不总是比 $Ο(N^2)$ 快。 不重要的项可以丢掉，比如：$Ο(N^2 + N)$ 变成 $Ο(N^2)$。类似高阶无穷小是无关紧要的。 $O(N^2) \\ne O(N*M)$，如果 N 和 M 没有建立关系，则两个变量都要保留。几个常见大 Ο 的增长速率 $O(1) &amp;lt; O(logN) &amp;lt; O(N) &amp;lt; O(NlogN) &amp;lt; O(N^{2)}&amp;lt; O(N^3) &amp;lt; O(2^N) &amp;lt; O(N!) &amp;lt; O(N^N)$ 多项式算法：加与乘 如果你的算法是“做这个，结束之后做那个”的形式，就是加 （两个独立的循环） 如果你的算法是“对这个的每个元素做那个”的形式，就是乘 （嵌套循环）O(logN) 运行时间如果每次操作都能把问题规模减半，则很可能是 $log$ 时间 比如二分查找，初始元素N个，每次搜索都会使问题规模减半。 每次搜索后剩下的元素个数分别为：N，N / 2，……，8，4，2，1 倒过来看：1，2，4，8，……，N / 2，N 设搜索一共执行了 k 次， 则 由 $2^k=N$（等比数列的通项公式） 得 $k = log_2N$递归的运行时间递归的题目，画出调用树，模拟代码的执行过程，使用树的公式计算时间复杂度，不要数个数！一般情况下，运行时间往往是 $O({分支数}^{数的深度})$ 或者 $O(N)$ （单分支）如果看到一个算法有多个递归调用，就可以认为它的运行时间是指数级的。int f(int n) { if (n &amp;lt;= 1) { return 1; } return f(n-1) + f(n-1);}flowchart TDA[&quot;f(4)&quot;] --&amp;gt; B[&quot;f(3)&quot;]A[&quot;f(4)&quot;] --&amp;gt; C[&quot;f(3)&quot;]B[&quot;f(3)&quot;] --&amp;gt; D[&quot;f(2)&quot;]B[&quot;f(3)&quot;] --&amp;gt; E[&quot;f(2)&quot;]C[&quot;f(3)&quot;] --&amp;gt; F[&quot;f(2)&quot;]C[&quot;f(3)&quot;] --&amp;gt; G[&quot;f(2)&quot;]D[&quot;f(2)&quot;] --&amp;gt; H[&quot;f(1)&quot;]D[&quot;f(2)&quot;] --&amp;gt; I[&quot;f(1)&quot;]E[&quot;f(2)&quot;] --&amp;gt; J[&quot;f(1)&quot;]E[&quot;f(2)&quot;] --&amp;gt; K[&quot;f(1)&quot;]F[&quot;f(2)&quot;] --&amp;gt; L[&quot;f(1)&quot;]F[&quot;f(2)&quot;] --&amp;gt; M[&quot;f(1)&quot;]G[&quot;f(2)&quot;] --&amp;gt; N[&quot;f(1)&quot;]G[&quot;f(2)&quot;] --&amp;gt; O[&quot;f(1)&quot;] 层 节点数 0 $2^0$ 1 $2^1$ 2 $2^2$ 3 $2^3$ 4 $2^4$ 节点总数为 $2^0 + 2^1+2^2+2^3+…+2^N = 2^{N+1}$一般情况下，运行时间往往是 $O({分支数}^{数的深度})$例题1. 程序员面试金典 6.10.例3void printUnorderedPairs(int[] array) { for (int i = 0; i &amp;lt; array.length; i++) { for (int j = i + 1; j &amp;lt; array.length; j++) { System.out.println(array[i] + &quot;,&quot; + array[j]); } } } 分析： i 和 j 共有 $N^2$ 种组合，这种情况下时间复杂度是 $O(N^2)$ 可以粗略地认为其中一半 i &amp;lt; j，另一半 i &amp;gt; j。 即 $O({1 \\over 2} N^2) = O(N)$2. 程序员面试金典 6.10.例9把平衡二叉搜索树上所有节点的值相加int sum(Node node) { if (node == null) { return 0; } return sum(node.left) + node.value + sum(node.right); } 分析： 仅仅是二叉搜索树不意味着 $log$ 时间 *仅仅是递归算法也不意味着 $2^N$ 时间** 问题出在调用栈的深度上，上面递归的例子，递归深度是 $N$，这个问题递归深度是 $log^N$ 即 $O(2^{logN}) = O(N)$3. 程序员面试金典 6.10.例16下面的函数递归地打印了从 1 到 n 中 2 的幂数。例如，如果 n 等于 4，它将打印 1、2、4。 它的运行时间是多少？int powersOf2(int n) { if (n &amp;lt; 1) { return 0; } else if (n == 1) { System.out.println(1); return 1; } else { int prev = powersOf2(n / 2); int curr = prev * 2; System.out.println(curr); return curr; } }分析： 它打印 1 到 n 中所有 2 的幂数。 因此，函数被调用的次数（相当于它的运行时间）应当等于 1 到 n 中 2 的幂数的个数。 1 到 n 中有 $logN$ 个 2 的幂数，因此，运行时间是 $Ο(logN)$。" }, { "title": "Pat 1473 A加b格式", "url": "/posts/PAT-1473-A%E5%8A%A0B%E6%A0%BC%E5%BC%8F/", "categories": "", "tags": "", "date": "2019-01-01 00:00:00 +0800", "snippet": "题目计算 a+b 并以标准格式输出总和—-也就是说，从最低位开始每隔三位数加进一个逗号（千位分隔符），如果结果少于四位则不需添加。输入格式共一行，包含两个整数 a 和 b。输出格式共一行，以标准格式输出 a+b 的和。输入样例：-1000000 9输出样例：-999,991题解 cin接受两个数字，求其和并转换成字符串 从后往前数，每三个数字加一个[，]，遇到[ - ]结束 #include &amp;lt;iostream&amp;gt; using namespace std; int main() { int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; int c = a + b; string num = to_string(c); string res; int j = 0; for (int i = num.size() - 1; i &amp;gt;= 0 ; --i) { ++j; res = num[i] + res; if (j % 3 == 0 &amp;amp;&amp;amp; i &amp;amp;&amp;amp; num[i - 1] != &#39;-&#39;) res = &quot;,&quot; + res; } cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl; return 0; } " }, { "title": "散列表", "url": "/posts/%E6%95%A3%E5%88%97%E8%A1%A8/", "categories": "", "tags": "", "date": "2018-12-25 00:00:00 +0800", "snippet": "散列表 散列表建立了Key和存储地址之间的一种直接映射关系，使查找速度极快。 如果冲突发生很多次，最坏情况下的时间复杂度是 $O(N)$，其中 N 是键的数量。 如果有一个不错的实现方式会将冲突数量保持在最低水平，在此情况下，时间复杂度是 $O(1)$。 哈希表使用列表作为桶存储 Key，使用链表存储 Value。如果列表空间太小，容易发生冲突；如果列表空间太大，会出现很多空位置，造成内存的浪费。散列函数 哈希表会针对每一个Key进行一次Hash运算，从而确定在桶(bucket)中的地址。 Hash函数本质上是从Key范围到地址范围的映射，Key的范围要远远大于地址的范围。 好的散列函数应尽量减少冲突。最好能够让地址等概率，均匀的分布在整个地址空间。 散列函数应尽可能简单，能够很快计算任一关键字对应的散列地址。 C# Dictionary 中实例对象和字符串通过内存地址计算 HashCode。 编写类时可以重写 Object.GetHashCode() 方法提供自己的 HashCode 计算方法。 实践中，采用何种散列函数取决于关键字集合的情况，目标是使产生冲突的可能性尽可能的低。 常用的Hash函数： 除留余数法：hash_key = Key % M 散列表中插入元素 使用散列函数计算出 Bob 的 Hash 值，再 mod 列表的长度，得到桶中的位置，插入。即： Hash(Key) % array_length 不同的 key 可能有相同地散列值，会被放到同一个桶中；不同的 key 算出不同的 Hash值 也有可能会被放到同一个桶中，因为列表长度始终有限。散列表中查找元素 使用散列函数计算出 Ally 的 Hash 值，再 mod 列表的长度，得到桶中的位置，再查找链表 ，看元素是否存在。除留余数法Hash函数Hash 的意义在于把一个大的集合A（key的集合）映射到小的集合B（地址的集合）。如果集合A的分布是均匀的，M取质数还是合数都可以，最后整个集合A都会被均匀的映射到B。但是，很多情况下我们的元素分布是有非1步长的，比如集合 $A = \\{ 0, 6, 12, 18, 24, 30, 36, … \\}$ ，这时候就出现问题了。当M取合数时，比如 $M = 10$，我们来看看映射的情况。0-&amp;gt; 0, 6-&amp;gt;6, 12-&amp;gt;2, 18-&amp;gt;8, 24-&amp;gt;4, 30-&amp;gt;0, 36-&amp;gt;6, …此时很容易发现，最后映射到了集合 $B = \\{0, 6, 2, 8, 4\\} = \\{0, 2, 4, 6, 8\\}$，和理想中的 $\\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\\}$ 差距很大。回到代数形式上来看，在Key与M最大公因数为1的情况下，Key % M 后可以得到的一系列的余数 r，而全体余数 r 的集合R就是 $\\{0, 1, 2, …, M-1\\}$。每个余数 r 代表了一个 N 的集合，比如在上面的例子中余数0代表了N的集合 ${0, 10, 20, 30, …}$，这个集合就叫做“同余类”。即余数集合R中有M个余数，每个余数 r 代表一个同余类。现在思路就很清晰了，我们最理想的方式就是将集合A映射到余数集合R上，即B = R。接下来我们讨论一下为什么有时候无法完全利用余数集合R：假设 N = kn, M = km， N 和 M 存在最大公因数 k，此时可以将 N % M = r 转化为公式 N = Mq + r ，即 kn = kmq + r。其中 q 是商，r 是余数。表面上 r 的取值范围是 $\\{0, 1, 2, …, M-1\\}$（忽视了只有N与M最大公因数为1时，才能取整个余数集合R的定理），一片和谐。但是可以对公式进行稍微的变换，n = mq + (r/k)，由于 n 和 mq 都是整数，则 (r/k) 也是整数。此时我们看到 (r/k) 的取值范围是 $\\{0, 1, 2, …, m\\} = \\{0, 1, 2, …, M/k\\}$ 。恢复到原式，也是就r的“实际”取值范围是 {0, k, 2*k, 3*k, …, m*k} ，缩小了k倍。一切都明了了，我们最后的目标就是保证Key与M最大公因数为1。最简单的方式就是直接取M为质数！一句话总结：Key和M的最大公因数越少，冲突的可能性越低，对余数集合R的利用率越高。处理冲突的方法 处理 Hash 冲突的方法有：开放定址法，再Hash法，拉链法，建立公共溢出区等。 C# Dictionary 字典类使用拉链法解决冲突。 查找过程： 给定Key，根据Hash函数求得Hash地址。 如果桶中此索引处没有记录，表示查找不成功。 否则依次比较链表中的关键字，若找到与给定值相等的，则查找成功，否则失败。 质数集合public static readonly int[] primes = { 3, 7, 11, 17, 23, 29, 37, 47, 59, 71, 89, 107, 131, 163, 197, 239, 293, 353, 431, 521, 631, 761, 919, 1103, 1327, 1597, 1931, 2333, 2801, 3371, 4049, 4861, 5839, 7013, 8419, 10103, 12143, 14591, 17519, 21023, 25229, 30293, 36353, 43627, 52361, 62851, 75431, 90523, 108631, 130363, 156437, 187751, 225307, 270371, 324449, 389357, 467237, 560689, 672827, 807403, 968897, 1162687, 1395263, 1674319, 2009191, 2411033, 2893249, 3471899, 4166287, 4999559, 5999471, 7199369};" }, { "title": "链表", "url": "/posts/%E9%93%BE%E8%A1%A8/", "categories": "", "tags": "", "date": "2018-12-12 00:00:00 +0800", "snippet": " 在链表中，数据的添加和删除都较为方便，就是访问比较耗费时间。存储 在链表中，数据一般都是分散存储于内存中的，无须存储在连续空间内。 因为数据都是分散存储的，所以如果想要访问数据，只能从第1个数据开始，顺着指针的指向一一往下访问（这便是顺序访问）。链表的时间复杂度 访问：O (n) 删除：O(1) 添加：O(1)循环链表 通常用于保存数量固定的最新数据。双向链表 双向链表会增加存储空间。 双向链表可以从后往前遍历数据。 添加和删除数据时需要改变更多指针的指向。链表的定义struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(nullptr) {}}" }, { "title": "二分查找", "url": "/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/", "categories": "", "tags": "", "date": "2018-12-12 00:00:00 +0800", "snippet": "算法特点 二分查找算法是搜索算法中用得最多、最简单易用、效率较好的搜索算法。 二分查找只能查找有序的数组。 在使用二分查找算法前，必须对数组进行排序，而且在每次更改、插入、删除后都要进行排序以保证数组的有序状态。算法步骤 将要查找的值与数组的中间位元素进行比较，若小于中间位，则在前半部分区域查找，若大于中间位，则在后半部分区域查找，如果等于中间位，则直接返回。 递归重复以上操作，知道范围缩到最小，如果还是没有找到匹配的元素，则说明元素并不在数组里。复杂度 平均时间复杂度为$O(logN)$" }, { "title": "快速排序", "url": "/posts/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/", "categories": "", "tags": "", "date": "2018-12-07 00:00:00 +0800", "snippet": "算法特点 序列很短的话，比如少于16个元素，就不要用快速排序了，换插入排序。 快速排序基于分治和递归。 目标是把所有比基准元素小的元素移到基准元素的左边，把比基准元素大的移到右边。算法步骤 先从序列中随机选择一个元素作为基准元素 Pivot，选哪个都没有影响，可以选末尾的。 从左往右找一个比 pivot 大的元素 L，再从右往左找一个比 pivot 小的元素 R，交换 L 和 R，重复此过程，直到左右游标相遇在 LR，把 LR 和 Pivot 交换，此时 Pivot 归位。pivot 把序列分成了左右两部分。 分别在左右两部分上重复步骤1，直到划分后的序列中只剩下一个元素。复杂度时间复杂度 平均/最优时间复杂度 $O(nlogn)$，其中logn为调用栈的深度 想象10000个元素的均匀序列，每一趟排序后，待排序序列平均分为两组，这样只需要 2logn 趟就能排好，所以T=O(nlogn) 如果序列原本即有序，最坏时间复杂度为 $O(n^2)$ 想象10000个元素的有序序列，每一趟排序后，待排序序列只会少1个元素，这样一共需要n趟才能排好。所以T = $O(n^n)$ 空间复杂度 快排没有开辟空间，但是使用了递归，递归会开辟栈帧，所以空间复杂度就是调用栈的深度，即 S = O(logn)。 如果序列原本就是有序排列，此时最坏空间复杂度 S = O(n)。稳定性 不稳定" }, { "title": "二叉查找树", "url": "/posts/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/", "categories": "", "tags": "", "date": "2018-12-07 00:00:00 +0800", "snippet": "二叉查找树 二叉查找树左边的子节点一定比父节点小，右边的子节点一定比父节点大。二叉查找树的性质 最小结点在左下的末端。如上图中的 3。 最大结点在右下的末端。如上图中的 28。添加数据 从根结点开始寻找插入位置，将想要添加的数据和结点比较。如果更小，就往左移；如果更大，就往右移。直到前面没有结点了，就把添加的数据作为叶子结点添加到二叉查找树中。删除数据 如果删除的结点没有子结点，直接删除即可。 如果删除的结点只有一个子结点，就先删除目标结点，然后把子结点移动到被删除结点的位置上。 如果删除的结点有两个子结点，就先删除目标结点，然后在被删除结点的左子树中寻找最大的结点，把它移动到被删除结点的位置上。如果移动的结点还有子结点，就递归的执行此过程。查找结点 从根结点开始查找，小于结点往左移动，大于结点往右移动。时间复杂度 查找：$O (logn)$ 添加：$O (logn)$ 删除：$O (logn)$和二分查找比较 二叉查找树是二分查找算法思想的树形结构体现。 算法的方式与二分查找算法类似，不同之处在于二分查找树构建出来的树形结构，由于原始数据的排列不同，有可能导致深度很大的二叉树犹如直线连接的节点，因此它是一个不稳定的查找方式，搜索的速度由原始数据的排列方式决定，若排列的顺序不好，则速度就不快，因此二叉树的稳定性并不高。" }, { "title": "归并排序", "url": "/posts/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/", "categories": "", "tags": "", "date": "2018-12-05 00:00:00 +0800", "snippet": "归并排序 把序列递归的分成长度相同的两个子序列，直到无法继续往下分时，就对子序列进行归并，即递归的把排好序的子序列合并成一个有序序列。时间复杂度 归并排序的运行时间 $O(nlogn)$ - 即树的高度" }, { "title": "堆排序", "url": "/posts/%E5%A0%86%E6%8E%92%E5%BA%8F/", "categories": "", "tags": "", "date": "2018-12-03 00:00:00 +0800", "snippet": "优先队列 优先队列可以自由添加数据，但取出数据时要从最小值开始按顺序取出。 堆是最高效的优先队列（Priority Queue）小根堆 小根堆的子结点必定大于父结点，最小值存储在根结点中。 堆是一种完全[[二叉树]]结构，可以用一维数组表示，这样会让效率更高，因为内存是连续的。 堆构建完成后能够得到一个头顶着最大值或最小值的数据结构，这种数据结构更有利于获取根节点的最大最小值节点。在后面的程序逻辑中，当需要插入新元素、修改旧元素及推出最大最小值时，效率都比较高。添加数据 插入的元素先放在二叉树的最后一个叶子节点的位置上。 如果父结点大于子结点，交换父子结点的位置。 重复此操作，直到不再需要交换为止。取出数据 删除根节点。 （重构堆1）把最后一个叶子节点拿过来放到根上。 （重构堆2）如果父结点大于子结点，把父结点同子结点中较小的那个交换。 重复此操作，直到不再需要交换为止。时间复杂度 取出最小值：O(1) 每轮构造或重构堆：$O(logn)$ - 即树的高度 堆排序的时间复杂度：$O(nlogn)$堆的应用 堆是最高效的优先队列。[[Dijkstra最短路径算法]]，每一步都需要从候补顶点中选择距离起点最近的那个顶点，在顶点的选择上可以用到堆。 堆排序也常用于 [[A*寻路算法]]。获取最大最小值时十分高效的特点，导致它在寻路系统的A星算法中特别有用。" }, { "title": "计算机网络分层体系结构", "url": "/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/", "categories": "", "tags": "", "date": "2018-10-19 00:00:00 +0800", "snippet": "" }, { "title": "计算机网络 应用层", "url": "/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/", "categories": "", "tags": "", "date": "2018-10-18 00:00:00 +0800", "snippet": "Web World Wide Web，万维网，是因特网上最主要的部分。Web协议[[HTTP]] - 超文本传输协议，万维网的主干FTP - 文件传输协议SVN - svn版本工具传输协议，也是基于万维网的File - 文件协议URL协议://主机:端口/路径 统一资源定位符：uniform resource locator其他因特网应用层协议[[SMTP]] - 电子邮件服务[[DNS]] - 域名解析服务[[DHCP]] - 动态主机配置协议网络管理命令[[ping]] - 测试目的站是否可达[[tracert]] - 显示到达目的主机的路径" }, { "title": "计算机网络 传输层", "url": "/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/", "categories": "", "tags": "", "date": "2018-10-17 00:00:00 +0800", "snippet": "传输层的功能 提供应用进程之间的逻辑通信。 复用：不同进程可以使用同一个传输层协议传输数据。 分用：接收方剥去报文首部后可以正确交付给目的进程。 对收到的报文进行差错检测。端口号和套接字端口 端口是传输层地SAP套接字 套接字 Socket = (主机IP地址 : 端口号) 套接字唯一地标识了网络中地一个主机和其上地一个应用进程。 TCP和UDP分别拥有自己地端口号，它们互不干扰，可以共存于同一台主机。TCPTCP的特点 TCP在不可靠的IP层之上实现了可靠的数据传输协议。 TCP是全双工的。 TCP面向字节流，传送时给每一个字节都编上序号。TCP数据像自来水一样连续流入盆中（缓存）。 TCP能够保证数据的正确性，也能够保证数据顺序到达，不可能丢包。 TCP像自动挡的汽车，连接，按序到达，可靠性，自动切包都已经内置了。应用场景 如果是由客户端间歇性地发起无状态的查询，并且偶尔发生的延迟可以容忍，那么就使用HTTP/HTTPS。 如果客户端和服务器都可以独立发包，但是偶尔发生的延迟可以容忍（比如在线的纸牌游戏、大部分MMO类游戏），那么使用TCP长连接。TCP报文段 TCP报文包头的最小长度为 20B。 单个数据包最大能承载 $2^{16}- 1 = 65,535$B 的数据。（16为窗口大小的位数）建立连接的三次握手断开连接的四次挥手UDPUDP的特点 UDP无连接，不可靠，尽最大努力交付。 使用UDP，应用层能更好的控制要发送的数据和发送时间。 应用层协议要自己限制合适的报文大小，以免报文太大导致丢包率高。 UDP为数据包模式，不是流模式，UDP数据像机关枪一样不停的扫射到目的地。 UDP不保证任何事情（不保证正确，不保证按顺序到达），且可能丢包。 UDP像手动挡汽车，只会简单的传输，什么都不能保证，但在效率上潜力巨大；只要应用层能够处理好需求，延迟比TCP低得多。应用场景 如果客户端和服务器都可以独立发包，而且无法忍受延迟（比如大多数多人动作类游戏、少部分MMO类游戏），那么使用UDP。UDP数据报" }, { "title": "计算机网络 网络层", "url": "/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/", "categories": "", "tags": "", "date": "2018-10-16 00:00:00 +0800", "snippet": "IP数据报手机查看局域网IP地址 手机找到 设置 -&amp;gt; WLAN -&amp;gt; 高级 -&amp;gt; IP地址" }, { "title": "计算机网络 网络接口层", "url": "/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82/", "categories": "", "tags": "", "date": "2018-10-15 00:00:00 +0800", "snippet": "" }, { "title": "斐波那契数列", "url": "/posts/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/", "categories": "", "tags": "", "date": "2018-10-05 00:00:00 +0800", "snippet": "斐波那契数列（黄金分割数）0, 1, 1, 2, 3, 5, 8, 13, 21,34, 55, 89, 144, 133…递归方程\\[F(n) = F(n-1) + F(n-2)\\]递归边界\\[F(0) = 0, F(1) = 1\\]递归计算// 计算第 i 个斐波那契数的递归算法public static int Fibonacci(int i) { if (i == 0) { return 0; } else if (i == 1 || i == 2) { return 1; } return Fibonacci(i - 1) + Fibonacci(i - 2);}Fibo = Fibonacci(5);" }, { "title": "面向对象的三大特征", "url": "/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/", "categories": "", "tags": "", "date": "2018-09-12 00:00:00 +0800", "snippet": "类是面向对象编程三大主要特征的基础。计算机中装了一个USB接口，这就是“封装”，而键盘、鼠标及摄像头都是USB接口的实现类，从广义上理解这就是一种“继承”，所以计算机的USB接口就能接驳各种各样的USB设备，这就是“多态”。封装 封装是类和对象和概念的主要特性。 封装的意义：隐藏类内部实现细节，暴露供外部类访问的接口，使代码模块化。 封装的例子：可乐，计算机主机，子弹…… 类型把字段，属性和方法组合到一起。 访问修饰符隐藏类型的数据和行为的内部实现细节，使类的内部工作机制不暴露。（private）封装要适度 如果把一些不相干的对象硬生生封装在一起，就会使代码变得莫名其妙，难于维护与管理，所谓“物极必反，过犹不及”，所以封装一定要适度。继承 继承可以复用现有类的所有功能，并在无需重新编写基类类的情况下对这些功能进行扩展。 派生类型和基类型。 继承的例子：DNA遗传 类继承，接口继承多态 polymorphisn 多态性意味着一个方法或类型可具有多种形式的实现。 接口也是实现多态的方式。动态多态 - 覆盖 override 覆盖是指派生类重新定义基类的虚函数的做法。 覆盖允许将派生类类型的指针赋值给基类类型的指针。 函数的调用在编译期间无法确定，因为调用的子类的虚函数的地址无法给出，函数地址是在运行期绑定的（晚邦定） 只有基类中被标记为 virtual 的实例方法和属性可以被重写；派生类使用 override 重写基类的方法，用 override 修饰的任何方法自动为虚。 把 Contact 转型成 PdaItem 类型后，内存中存储的依然是 Contact 类型，调用虚方法会调用派生的最远的（most derived）实现。虚方法public class PdaItem{ public virtual string Name { get; set; }}public class Contact : PdaItem{ public override string Name { get {} set {} }}静态多态 - 重载 Overload （伪多态） 重载允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。 重载在编译器就能够确定下来要调用的方法，编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数，是早绑定，编译期绑定。 方法的唯一性取决于方法名、参数数据类型或参数数量的差异。 方法重载是一种操作性多态（operational polymorphism）。如由于数据变化造成同一个逻辑操作具有许多（“多”）形式（“态”），就会发生“多态”。实现重载的常用模式 在一个方法中实现核心逻辑，其他所有重载版本都调用那个方法。 将核心功能放到单一方法中供其他重载方法调用，以后就只需在核心方法中修改，其他方法将自动受益。" }, { "title": "进程与线程", "url": "/posts/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/", "categories": "", "tags": "", "date": "2018-08-12 00:00:00 +0800", "snippet": "并发和并行 并发：在一个时间段内有多个进程/线程同时执行。可通过时间片轮转实现并发。 并行：在同一时刻有多个进程/线程同时执行。物理上的多核CPU才能实现并行。进程 Process 进程是某个程序当前正在执行的实例。是系统进行资源分配的基本单位。进程控制块 PCB Process Control Block，即进程控制块。 PCB是一个数据结构，创建一个进程，就是创建PCB；撤销一个进程，就是撤销其PCB。 PCB是进程存在的唯一标志。 进程 = PCB + 程序段 + 相关数据段。 PCB中存储的内容有：UID，PID，进程状态信息，段指针，打开的文件，访问的资源，寄存器数据副本，CPU现场等。进程生命周期 运行态 阻塞态：如等待网络请求返回结果 就绪态进程间通信方式 共享存储。 消息传递（类似于网络传输）。 管道通信。C#进程类System.Dianostics.Process;线程 Thread 线程是系统调度的基本单位。 每个进程包含一个或多个线程。多线程的优点 执行I/O受限操作的线程会被操作系统忽略，直到I/O子系统返回结果。所以，从I/O受限线程切换到处理器受限线程能提高处理器利用率，防止处理器在等待I/O操作完成期间闲置。多线程的缺点 上下文切换有代价：必须将CPU当前的内部状态保存到内存，还必须加载与新线程关联的状态。如线程太多，切换开销就会开始显著影响性能。 时间分片本身对性能也有巨大影响。 要在通过多线程来加快解决处理器受限问题时谨慎衡量性能。C#线程类System.Threading.ThreadUI线程 UI是单线程的，与任何UI组件（例如，文本框）的交互必须始终发生在单个UI线程中。线程池 线程池是多个线程的集合，通过一定逻辑决定如何为线程分配工作。有任务要执行时，它分配池中的一个工作者线程执行任务，并在任务结束后解除分配，从而使该线程在下次请求额外工作时可用。 线程池避免了启动和终止线程的巨大开销。此外，线程池避免了太多线程的创建，防止系统将大多数时间花在线程的切换而不是运行上。调整线程数量的启发式算法 爬山算法：爬山算法在开始阶段不断创建新线程来运行任务，然后监控这些任务的性能。当发现性能开始下降时就减少线程，使性能回升到最佳。 工作窃取算法：工作窃取算法能够识别工作量过度饱和以及过度枯竭的线程。工作量不足的线程会从过于繁忙的线程“窃取”任务。" } ]
