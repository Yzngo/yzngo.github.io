

1. 渲染顺序关注的是所有的 drawcall 以什么样的顺序渲染；每个网格谁先渲染，谁后渲染。
2. 所有的网格先在CPU中排序，按照排好的顺序依次调用drawcall指令进入渲染管线进行渲染。
3. 如果先渲染离屏幕近的物体，那么就能在ZTest的机制下早早地屏蔽掉后面地片元，提升GPU地效率。


### Unity渲染队列

1. 每个物体进入不同的渲染队列，Queue值越小的越先渲染；每个队列中，按照距离摄像机的远近排序，其中：2500以下索引号的被认为是不透明物体，根据摄像机的距离由近及远地渲染（越早剔除越好）；2500以上索引号的被认为是半透明物体，根据摄像机的距离由远及近地渲染（为了正确的混合）。

##### 背景层 Background : Queue = 1000

##### 不透明物体 Geometry : Queue = 2000

1. 不透明物体离摄像机近地排在前面渲染，远的放在后面渲染。

##### 半透明物体 Transparent : Queue = 3000

1. [[半透明物体]]需要混合，所以其渲染排在所有不透明物体之后。
2. 为保证混合的正确性，半透明物体离摄像机远的先渲染。
3. 半透明物体可以通过 `Sorting Priority` 改变渲染优先级。
4. 如果两个物体的网格面片相交，或者同一个物体中的面片相互交错，则无法再区分片元的前后关系。原因是它们没有写入片元的深度值，即ZWrite为关闭状态，不能用深度值去判定片元是否覆盖或被覆盖；若为打开状态，则又会出现混合失效的情况，因为片元底下覆盖的片元被彻底抛弃，所以没有混合一说了。因此，使用Blend制作半透明物体，在复杂的半透明交叉情况下，通常很难做到前后关系有序。参考：[[渲染管线#深度测试 - Depth Test]]
5. 如果把不透明物体放到半透明队列中，也会参与混合。


##### 覆盖层 Overlay : Queue = 4000