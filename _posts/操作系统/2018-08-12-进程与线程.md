

### 并发和并行

1. 并发：在**一个时间段**内有多个进程/线程同时执行。可通过**时间片轮转**实现并发。
2. 并行：在**同一时刻**有多个进程/线程同时执行。**物理上的多核CPU**才能实现并行。

![image-20230205162817009](https://cdn.jsdelivr.net/gh/yzngo/ImageHosting/img/202302051628040.png)



### 进程 Process

1. 进程是某个程序当前正在执行的实例。是系统进行**资源分配**的基本单位。

##### 进程控制块 PCB

1. Process Control Block，即进程控制块。
4. PCB是一个数据结构，创建一个进程，就是创建PCB；撤销一个进程，就是撤销其PCB。
5. **PCB是进程存在的唯一标志。**
6. 进程 = PCB + 程序段 + 相关数据段。
7. PCB中存储的内容有：UID，PID，进程状态信息，段指针，打开的文件，访问的资源，寄存器数据副本，CPU现场等。

##### 进程生命周期

![image-20230205162830272](https://cdn.jsdelivr.net/gh/yzngo/ImageHosting/img/202302051628298.png)

1. 运行态
2. 阻塞态：如等待网络请求返回结果
3. 就绪态

##### 进程间通信方式

1. 共享存储。
2. 消息传递（类似于网络传输）。
3. 管道通信。


##### C#进程类

```cs
System.Dianostics.Process;
```


### 线程 Thread

1. 线程是系统**调度**的基本单位。
2. 每个进程包含一个或多个线程。


##### 多线程的优点

1. 执行**I/O受限**操作的线程会被操作系统忽略，直到I/O子系统返回结果。所以，从I/O受限线程切换到处理器受限线程能提高处理器利用率，防止处理器在等待I/O操作完成期间闲置。

##### 多线程的缺点

1. 上下文切换有代价：必须将CPU当前的内部状态保存到内存，还必须加载与新线程关联的状态。如线程太多，切换开销就会开始显著影响性能。
2. 时间分片本身对性能也有巨大影响。
3. 要在通过多线程来加快解决**处理器受限**问题时谨慎衡量性能。


##### C#线程类

```cs
System.Threading.Thread
```

##### UI线程

1. UI是单线程的，与任何UI组件（例如，文本框）的交互必须始终发生在单个UI线程中。

### 线程池

1. 线程池是多个线程的集合，通过一定逻辑决定如何为线程分配工作。有任务要执行时，它分配池中的一个工作者线程执行任务，并在任务结束后解除分配，从而使该线程在下次请求额外工作时可用。
2. 线程池避免了启动和终止线程的巨大开销。此外，线程池避免了太多线程的创建，防止系统将大多数时间花在线程的切换而不是运行上。

##### 调整线程数量的启发式算法

1. 爬山算法：爬山算法在开始阶段不断创建新线程来运行任务，然后监控这些任务的性能。当发现性能开始下降时就减少线程，使性能回升到最佳。
2. 工作窃取算法：工作窃取算法能够识别工作量过度饱和以及过度枯竭的线程。工作量不足的线程会从过于繁忙的线程“窃取”任务。
